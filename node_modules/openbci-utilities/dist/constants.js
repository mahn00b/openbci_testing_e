(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["OpenBCIUtilities"] = factory();
	else
		root["OpenBCIUtilities"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(2)\nvar ieee754 = __webpack_require__(3)\nvar isArray = __webpack_require__(4)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/node-libs-browser/node_modules/buffer/index.js\n// module id = 0\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/base64-js/index.js\n// module id = 2\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ieee754/index.js\n// module id = 3\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/isarray/index.js\n// module id = 4\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer___);\n/**\n* Created by ajk on 12/16/15.\n* Purpose: This file folds all the constants for the\n*     OpenBCI Board\n*/\n\n\n\n\n/** Turning channels off */\nconst obciChannelOff1 = '1';\nconst obciChannelOff2 = '2';\nconst obciChannelOff3 = '3';\nconst obciChannelOff4 = '4';\nconst obciChannelOff5 = '5';\nconst obciChannelOff6 = '6';\nconst obciChannelOff7 = '7';\nconst obciChannelOff8 = '8';\nconst obciChannelOff9 = 'q';\nconst obciChannelOff10 = 'w';\nconst obciChannelOff11 = 'e';\nconst obciChannelOff12 = 'r';\nconst obciChannelOff13 = 't';\nconst obciChannelOff14 = 'y';\nconst obciChannelOff15 = 'u';\nconst obciChannelOff16 = 'i';\n\n/** Turn channels on */\nconst obciChannelOn1 = '!';\nconst obciChannelOn2 = '@';\nconst obciChannelOn3 = '#';\nconst obciChannelOn4 = '$';\nconst obciChannelOn5 = '%';\nconst obciChannelOn6 = '^';\nconst obciChannelOn7 = '&';\nconst obciChannelOn8 = '*';\nconst obciChannelOn9 = 'Q';\nconst obciChannelOn10 = 'W';\nconst obciChannelOn11 = 'E';\nconst obciChannelOn12 = 'R';\nconst obciChannelOn13 = 'T';\nconst obciChannelOn14 = 'Y';\nconst obciChannelOn15 = 'U';\nconst obciChannelOn16 = 'I';\n\n/** Test Signal Control Commands\n* 1x - Voltage will be 1 * (VREFP - VREFN) / 2.4 mV\n* 2x - Voltage will be 2 * (VREFP - VREFN) / 2.4 mV\n*/\nconst obciTestSignalConnectToDC = 'p';\nconst obciTestSignalConnectToGround = '0';\nconst obciTestSignalConnectToPulse1xFast = '=';\nconst obciTestSignalConnectToPulse1xSlow = '-';\nconst obciTestSignalConnectToPulse2xFast = ']';\nconst obciTestSignalConnectToPulse2xSlow = '[';\n\n/** Channel Setting Commands */\nconst obciChannelCmdADCNormal = '0';\nconst obciChannelCmdADCShorted = '1';\nconst obciChannelCmdADCBiasDRP = '6';\nconst obciChannelCmdADCBiasDRN = '7';\nconst obciChannelCmdADCBiasMethod = '2';\nconst obciChannelCmdADCMVDD = '3';\nconst obciChannelCmdADCTemp = '4';\nconst obciChannelCmdADCTestSig = '5';\nconst obciChannelCmdBiasInclude = '1';\nconst obciChannelCmdBiasRemove = '0';\nconst obciChannelCmdChannel1 = '1';\nconst obciChannelCmdChannel2 = '2';\nconst obciChannelCmdChannel3 = '3';\nconst obciChannelCmdChannel4 = '4';\nconst obciChannelCmdChannel5 = '5';\nconst obciChannelCmdChannel6 = '6';\nconst obciChannelCmdChannel7 = '7';\nconst obciChannelCmdChannel8 = '8';\nconst obciChannelCmdChannel9 = 'Q';\nconst obciChannelCmdChannel10 = 'W';\nconst obciChannelCmdChannel11 = 'E';\nconst obciChannelCmdChannel12 = 'R';\nconst obciChannelCmdChannel13 = 'T';\nconst obciChannelCmdChannel14 = 'Y';\nconst obciChannelCmdChannel15 = 'U';\nconst obciChannelCmdChannel16 = 'I';\nconst obciChannelCmdGain1 = '0';\nconst obciChannelCmdGain2 = '1';\nconst obciChannelCmdGain4 = '2';\nconst obciChannelCmdGain6 = '3';\nconst obciChannelCmdGain8 = '4';\nconst obciChannelCmdGain12 = '5';\nconst obciChannelCmdGain24 = '6';\nconst obciChannelCmdLatch = 'X';\nconst obciChannelCmdPowerOff = '1';\nconst obciChannelCmdPowerOn = '0';\nconst obciChannelCmdSet = 'x';\nconst obciChannelCmdSRB1Connect = '1';\nconst obciChannelCmdSRB1Diconnect = '0';\nconst obciChannelCmdSRB2Connect = '1';\nconst obciChannelCmdSRB2Diconnect = '0';\n\n/** Channel Setting Helper Strings */\nconst obciStringADCNormal = 'normal';\nconst obciStringADCShorted = 'shorted';\nconst obciStringADCBiasMethod = 'biasMethod';\nconst obciStringADCMvdd = 'mvdd';\nconst obciStringADCTemp = 'temp';\nconst obciStringADCTestSig = 'testSig';\nconst obciStringADCBiasDrp = 'biasDrp';\nconst obciStringADCBiasDrn = 'biasDrn';\n\n/** Default Channel Settings */\nconst obciChannelDefaultAllSet = 'd';\nconst obciChannelDefaultAllGet = 'D';\n\n/** LeadOff Impedance Commands */\nconst obciChannelImpedanceLatch = 'Z';\nconst obciChannelImpedanceSet = 'z';\nconst obciChannelImpedanceTestSignalApplied = '1';\nconst obciChannelImpedanceTestSignalAppliedNot = '0';\n\n/** SD card Commands */\nconst obciSDLogForHour1 = 'G';\nconst obciSDLogForHour2 = 'H';\nconst obciSDLogForHour4 = 'J';\nconst obciSDLogForHour12 = 'K';\nconst obciSDLogForHour24 = 'L';\nconst obciSDLogForMin5 = 'A';\nconst obciSDLogForMin15 = 'S';\nconst obciSDLogForMin30 = 'F';\nconst obciSDLogForSec14 = 'a';\nconst obciSDLogStop = 'j';\n\n/** SD Card String Commands */\nconst obciStringSDHour1 = '1hour';\nconst obciStringSDHour2 = '2hour';\nconst obciStringSDHour4 = '4hour';\nconst obciStringSDHour12 = '12hour';\nconst obciStringSDHour24 = '24hour';\nconst obciStringSDMin5 = '5min';\nconst obciStringSDMin15 = '15min';\nconst obciStringSDMin30 = '30min';\nconst obciStringSDSec14 = '14sec';\n\n/** Stream Data Commands */\nconst obciStreamStart = 'b';\nconst obciStreamStop = 's';\n\n/** Miscellaneous */\nconst obciMiscQueryRegisterSettings = '?';\nconst obciMiscQueryRegisterSettingsChannel1 = 'CH1SET';\nconst obciMiscQueryRegisterSettingsChannel2 = 'CH2SET';\nconst obciMiscQueryRegisterSettingsChannel3 = 'CH3SET';\nconst obciMiscQueryRegisterSettingsChannel4 = 'CH4SET';\nconst obciMiscQueryRegisterSettingsChannel5 = 'CH5SET';\nconst obciMiscQueryRegisterSettingsChannel6 = 'CH6SET';\nconst obciMiscQueryRegisterSettingsChannel7 = 'CH7SET';\nconst obciMiscQueryRegisterSettingsChannel8 = 'CH8SET';\nconst obciMiscSoftReset = 'v';\n\n/** 16 Channel Commands */\nconst obciChannelMaxNumber8 = 'c';\nconst obciChannelMaxNumber16 = 'C';\nconst obciChannelMaxNumber8NoDaisyToRemove = '';\nconst obciChannelMaxNumber8SuccessDaisyRemoved = 'daisy removed';\nconst obciChannelMaxNumber16DaisyAlreadyAttached = '16';\nconst obciChannelMaxNumber16DaisyAttached = 'daisy attached16';\nconst obciChannelMaxNumber16NoDaisyAttached = 'no daisy to attach!8';\n\n/** 60Hz line filter */\nconst obciFilterDisable = 'g';\nconst obciFilterEnable = 'f';\n\n/** Triggers */\nconst obciTrigger = '`';\n\n/** Sync Clocks */\nconst obciSyncTimeSet = '<';\nconst obciSyncTimeSent = ',';\n\n/** Set board mode */\nconst obciBoardModeSet = '/';\nconst obciBoardModeCmdDefault = '0';\nconst obciBoardModeCmdDebug = '1';\nconst obciBoardModeCmdAnalog = '2';\nconst obciBoardModeCmdDigital = '3';\nconst obciBoardModeCmdGetCur = '/';\nconst obciBoardModeAnalog = 'analog';\nconst obciBoardModeDefault = 'default';\nconst obciBoardModeDebug = 'debug';\nconst obciBoardModeDigital = 'digital';\n\n/** Set sample rate */\nconst obciSampleRateSet = '~';\nconst obciSampleRateCmdCyton16000 = '0';\nconst obciSampleRateCmdCyton8000 = '1';\nconst obciSampleRateCmdCyton4000 = '2';\nconst obciSampleRateCmdCyton2000 = '3';\nconst obciSampleRateCmdCyton1000 = '4';\nconst obciSampleRateCmdCyton500 = '5';\nconst obciSampleRateCmdCyton250 = '6';\nconst obciSampleRateCmdGang25600 = '0';\nconst obciSampleRateCmdGang12800 = '1';\nconst obciSampleRateCmdGang6400 = '2';\nconst obciSampleRateCmdGang3200 = '3';\nconst obciSampleRateCmdGang1600 = '4';\nconst obciSampleRateCmdGang800 = '5';\nconst obciSampleRateCmdGang400 = '6';\nconst obciSampleRateCmdGang200 = '7';\nconst obciSampleRateCmdaGetCur = '~';\n\n/** Accel enable/disable commands */\nconst obciAccelStart = 'n';\nconst obciAccelStop = 'N';\n\n/** Wifi Stuff */\nconst obciWifiAttach = '{';\nconst obciWifiRemove = '}';\nconst obciWifiReset = ';';\nconst obciWifiStatus = ':';\n\n/** Radio Key */\nconst obciRadioKey = 0xF0;\n/** Radio Commands */\nconst obciRadioCmdChannelGet = 0x00;\nconst obciRadioCmdChannelSet = 0x01;\nconst obciRadioCmdChannelSetOverride = 0x02;\nconst obciRadioCmdPollTimeGet = 0x03;\nconst obciRadioCmdPollTimeSet = 0x04;\nconst obciRadioCmdBaudRateSetDefault = 0x05;\nconst obciRadioCmdBaudRateSetFast = 0x06;\nconst obciRadioCmdSystemStatus = 0x07;\n\n/** Possible number of channels */\nconst obciNumberOfChannelsCyton = 8;\nconst obciNumberOfChannelsCytonBLE = 2;\nconst obciNumberOfChannelsDaisy = 16;\nconst obciNumberOfChannelsDefault = obciNumberOfChannelsCyton;\nconst obciNumberOfChannelsGanglion = 4;\n\n/** Possible OpenBCI board types */\nconst obciBoardCyton = 'cyton';\nconst obciBoardCytonBLE = 'cytonBLE';\nconst obciBoardDaisy = 'daisy';\nconst obciBoardDefault = 'default';\nconst obciBoardGanglion = 'ganglion';\nconst obciBoardNone = 'none';\n\n/** Possible Simulator Line Noise injections */\nconst obciSimulatorLineNoiseHz60 = '60Hz';\nconst obciSimulatorLineNoiseHz50 = '50Hz';\nconst obciSimulatorLineNoiseNone = 'none';\n\n/** Possible Simulator Fragmentation modes */\nconst obciSimulatorFragmentationRandom = 'random';\nconst obciSimulatorFragmentationFullBuffers = 'fullBuffers';\nconst obciSimulatorFragmentationOneByOne = 'oneByOne';\nconst obciSimulatorFragmentationNone = 'none';\n\n/** Possible Sample Rates */\nconst obciSampleRate1000 = 1000;\nconst obciSampleRate125 = 125;\nconst obciSampleRate12800 = 12800;\nconst obciSampleRate1600 = 1600;\nconst obciSampleRate16000 = 16000;\nconst obciSampleRate200 = 200;\nconst obciSampleRate2000 = 2000;\nconst obciSampleRate250 = 250;\nconst obciSampleRate25600 = 25600;\nconst obciSampleRate3200 = 3200;\nconst obciSampleRate400 = 400;\nconst obciSampleRate4000 = 4000;\nconst obciSampleRate500 = 500;\nconst obciSampleRate6400 = 6400;\nconst obciSampleRate800 = 800;\nconst obciSampleRate8000 = 8000;\n\n/** Max sample number */\nconst obciSampleNumberMax = 255;\n\n/** Packet Size */\nconst obciPacketSize = 33;\nconst obciPacketSizeBLECyton = 20;\nconst obciPacketSizeBLERaw = 12;\n\n/** OpenBCI V3 Standard Packet Positions */\n/**\n* 0:[startByte] | 1:[sampleNumber] | 2:[Channel-1.1] | 3:[Channel-1.2] | 4:[Channel-1.3] | 5:[Channel-2.1] | 6:[Channel-2.2] | 7:[Channel-2.3] | 8:[Channel-3.1] | 9:[Channel-3.2] | 10:[Channel-3.3] | 11:[Channel-4.1] | 12:[Channel-4.2] | 13:[Channel-4.3] | 14:[Channel-5.1] | 15:[Channel-5.2] | 16:[Channel-5.3] | 17:[Channel-6.1] | 18:[Channel-6.2] | 19:[Channel-6.3] | 20:[Channel-7.1] | 21:[Channel-7.2] | 22:[Channel-7.3] | 23:[Channel-8.1] | 24:[Channel-8.2] | 25:[Channel-8.3] | 26:[Aux-1.1] | 27:[Aux-1.2] | 28:[Aux-2.1] | 29:[Aux-2.2] | 30:[Aux-3.1] | 31:[Aux-3.2] | 32:StopByte\n*/\nconst obciPacketPositionChannelDataStart = 2; // 0:startByte | 1:sampleNumber | [2:4] | [5:7] | [8:10] | [11:13] | [14:16] | [17:19] | [21:23] | [24:26]\nconst obciPacketPositionChannelDataStop = 25; // 24 bytes for channel data\nconst obciPacketPositionSampleNumber = 1;\nconst obciPacketPositionStartByte = 0; // first byte\nconst obciPacketPositionStopByte = 32; // [32]\nconst obciPacketPositionStartAux = 26; // [26,27]:Aux 1 | [28,29]:Aux 2 | [30,31]:Aux 3\nconst obciPacketPositionStopAux = 31; // - - - [30,31]:Aux 3 | 32: Stop byte\nconst obciPacketPositionTimeSyncAuxStart = 26;\nconst obciPacketPositionTimeSyncAuxStop = 28;\nconst obciPacketPositionTimeSyncTimeStart = 28;\nconst obciPacketPositionTimeSyncTimeStop = 32;\n\n/** Notable Bytes */\nconst obciByteStart = 0xA0;\nconst obciByteStop = 0xC0;\n\n/** Errors */\nconst errorInvalidByteLength = 'Invalid Packet Byte Length';\nconst errorInvalidByteStart = 'Invalid Start Byte';\nconst errorInvalidByteStop = 'Invalid Stop Byte';\nconst errorInvalidData = 'Invalid data - try again';\nconst errorInvalidType = 'Invalid type - check comments for input type';\nconst errorMissingRegisterSetting = 'Missing register setting';\nconst errorMissingRequiredProperty = 'Missing property in JSON';\nconst errorNobleAlreadyScanning = 'Scan already under way';\nconst errorNobleNotAlreadyScanning = 'No scan started';\nconst errorNobleNotInPoweredOnState = 'Please turn blue tooth on.';\nconst errorTimeSyncIsNull = \"'this.sync.curSyncObj' must not be null\";\nconst errorTimeSyncNoComma = 'Missed the time sync sent confirmation. Try sync again';\nconst errorUndefinedOrNullInput = 'Undefined or Null Input';\n\n/** Max Master Buffer Size */\nconst obciMasterBufferSize = 4096;\n\n/** Impedance Calculation Variables */\nconst obciLeadOffDriveInAmps = 0.000000006;\nconst obciLeadOffFrequencyHz = 31.5;\n\n/** Command send delay */\nconst obciWriteIntervalDelayMSLong = 50;\nconst obciWriteIntervalDelayMSNone = 0;\nconst obciWriteIntervalDelayMSShort = 10;\n\n/** Impedance */\nconst obciImpedanceTextBad = 'bad';\nconst obciImpedanceTextNone = 'none';\nconst obciImpedanceTextGood = 'good';\nconst obciImpedanceTextInit = 'init';\nconst obciImpedanceTextOk = 'ok';\n\nconst obciImpedanceThresholdGoodMin = 0;\nconst obciImpedanceThresholdGoodMax = 5000;\nconst obciImpedanceThresholdOkMin = 5001;\nconst obciImpedanceThresholdOkMax = 10000;\nconst obciImpedanceThresholdBadMin = 10001;\nconst obciImpedanceThresholdBadMax = 1000000;\n\nconst obciImpedanceSeriesResistor = 2200; // There is a 2.2 k Ohm series resistor that must be subtracted\n\n/** Simulator */\nconst obciSimulatorPortName = 'OpenBCISimulator';\n\n/**\n* Stream packet types/codes\n*/\nconst obciStreamPacketStandardAccel = 0; // 0000\nconst obciStreamPacketStandardRawAux = 1; // 0001\nconst obciStreamPacketUserDefinedType = 2; // 0010\nconst obciStreamPacketAccelTimeSyncSet = 3; // 0011\nconst obciStreamPacketAccelTimeSynced = 4; // 0100\nconst obciStreamPacketRawAuxTimeSyncSet = 5; // 0101\nconst obciStreamPacketRawAuxTimeSynced = 6; // 0110\nconst obciStreamPacketImpedance = 7; // 0111\n\n/** Time from board */\nconst obciStreamPacketTimeByteSize = 4;\n\n/** Time synced with accel packet */\nconst obciAccelAxisX = 7;\nconst obciAccelAxisY = 8;\nconst obciAccelAxisZ = 9;\n\n/** Firmware version indicator */\nconst obciFirmwareV1 = 'v1';\nconst obciFirmwareV2 = 'v2';\nconst obciFirmwareV3 = 'v3';\n\n/** Parse */\nconst obciParseDaisy = 'Daisy';\nconst obciParseFirmware = 'v2';\nconst obciParseFailure = 'Failure';\nconst obciParseEOT = '$$$';\nconst obciParseSuccess = 'Success';\n\n/** Used in parsing incoming serial data */\nconst obciParsingChannelSettings = 2;\nconst obciParsingEOT = 4;\nconst obciParsingNormal = 3;\nconst obciParsingReset = 0;\nconst obciParsingTimeSyncSent = 1;\n\n/** Timeouts */\nconst obciTimeoutProcessBytes = 500; // 0.5 seconds\n\n/** Simulator Board Configurations */\nconst obciSimulatorRawAux = 'rawAux';\nconst obciSimulatorStandard = 'standard';\n\n/** OpenBCI Radio Limits */\nconst obciRadioChannelMax = 25;\nconst obciRadioChannelMin = 1;\nconst obciRadioPollTimeMax = 255;\nconst obciRadioPollTimeMin = 0;\n\n/** Time sync stuff */\nconst obciTimeSyncArraySize = 10;\nconst obciTimeSyncMultiplierWithSyncConf = 0.9;\nconst obciTimeSyncMultiplierWithoutSyncConf = 0.75;\nconst obciTimeSyncThresholdTransFailureMS = 10; // ms\n\n/** Baud Rates */\nconst obciRadioBaudRateDefault = 115200;\nconst obciRadioBaudRateDefaultStr = 'default';\nconst obciRadioBaudRateFast = 230400;\nconst obciRadioBaudRateFastStr = 'fast';\n\n/** Emitters */\nconst obciEmitterAccelerometer = 'accelerometer';\nconst obciEmitterBlePoweredUp = 'blePoweredOn';\nconst obciEmitterClose = 'close';\nconst obciEmitterDroppedPacket = 'droppedPacket';\nconst obciEmitterEot = 'eot';\nconst obciEmitterError = 'error';\nconst obciEmitterGanglionFound = 'ganglionFound';\nconst obciEmitterHardSet = 'hardSet';\nconst obciEmitterImpedance = 'impedance';\nconst obciEmitterImpedanceArray = 'impedanceArray';\nconst obciEmitterMessage = 'message';\nconst obciEmitterQuery = 'query';\nconst obciEmitterRawDataPacket = 'rawDataPacket';\nconst obciEmitterReady = 'ready';\nconst obciEmitterRFduino = 'rfduino';\nconst obciEmitterSample = 'sample';\nconst obciEmitterScanStopped = 'scanStopped';\nconst obciEmitterSynced = 'synced';\nconst obciEmitterWifiShield = 'wifiShield';\n\n/** Accel packets */\nconst obciGanglionAccelAxisX = 1;\nconst obciGanglionAccelAxisY = 2;\nconst obciGanglionAccelAxisZ = 3;\n\n/** Accel scale factor */\nconst obciGanglionAccelScaleFactor = 0.016; // mG per count\n\n/** Ganglion */\nconst obciGanglionBleSearchTime = 20000; // ms\nconst obciGanglionByteIdUncompressed = 0;\nconst obciGanglionByteId18Bit = {\n  max: 100,\n  min: 1\n};\nconst obciGanglionByteId19Bit = {\n  max: 200,\n  min: 101\n};\nconst obciGanglionByteIdImpedanceChannel1 = 201;\nconst obciGanglionByteIdImpedanceChannel2 = 202;\nconst obciGanglionByteIdImpedanceChannel3 = 203;\nconst obciGanglionByteIdImpedanceChannel4 = 204;\nconst obciGanglionByteIdImpedanceChannelReference = 205;\nconst obciGanglionByteIdMultiPacket = 206;\nconst obciGanglionByteIdMultiPacketStop = 207;\nconst obciGanglionPacketSize = 20;\nconst obciGanglionSamplesPerPacket = 2;\nconst obciGanglionPacket18Bit = {\n  auxByte: 20,\n  byteId: 0,\n  dataStart: 1,\n  dataStop: 19\n};\nconst obciGanglionPacket19Bit = {\n  byteId: 0,\n  dataStart: 1,\n  dataStop: 20\n};\nconst obciGanglionMCP3912Gain = 51.0; // assumed gain setting for MCP3912.  NEEDS TO BE ADJUSTABLE JM\nconst obciGanglionMCP3912Vref = 1.2; // reference voltage for ADC in MCP3912 set in hardware\nconst obciGanglionPrefix = 'Ganglion';\nconst obciGanglionSyntheticDataEnable = 't';\nconst obciGanglionSyntheticDataDisable = 'T';\nconst obciGanglionImpedanceStart = 'z';\nconst obciGanglionImpedanceStop = 'Z';\nconst obciGanglionScaleFactorPerCountVolts = obciGanglionMCP3912Vref / (8388607.0 * obciGanglionMCP3912Gain * 1.5);\n\n/** Simblee */\nconst simbleeUuidService = 'fe84';\nconst simbleeUuidReceive = '2d30c082f39f4ce6923f3484ea480596';\nconst simbleeUuidSend = '2d30c083f39f4ce6923f3484ea480596';\nconst simbleeUuidDisconnect = '2d30c084f39f4ce6923f3484ea480596';\n\n/** RFduino BLE UUID */\nconst rfduinoUuidService = '2220';\nconst rfduinoUuidReceive = '2221';\nconst rfduinoUuidSend = '2222';\nconst rfduinoUuidSendTwo = '2223';\n\n/** Cyton BLE */\nconst obciCytonBLESamplesPerPacket = 3;\n\n/** Noble */\nconst obciNobleEmitterPeripheralConnect = 'connect';\nconst obciNobleEmitterPeripheralDisconnect = 'disconnect';\nconst obciNobleEmitterPeripheralDiscover = 'discover';\nconst obciNobleEmitterPeripheralServicesDiscover = 'servicesDiscover';\nconst obciNobleEmitterServiceCharacteristicsDiscover = 'characteristicsDiscover';\nconst obciNobleEmitterServiceRead = 'read';\nconst obciNobleEmitterDiscover = 'discover';\nconst obciNobleEmitterScanStart = 'scanStart';\nconst obciNobleEmitterScanStop = 'scanStop';\nconst obciNobleEmitterStateChange = 'stateChange';\nconst obciNobleStatePoweredOn = 'poweredOn';\n\n/** Protocols */\nconst obciProtocolBLE = 'ble';\nconst obciProtocolSerial = 'serial';\nconst obciProtocolWifi = 'wifi';\n\n/** Register Query on Cyton */\nconst obciRegisterQueryAccelerometerFirmwareV1 = '\\nLIS3DH Registers\\n0x07.0\\n0x08.0\\n0x09.0\\n0x0A.0\\n0x0B.0\\n0x0C.0\\n0x0D.0\\n0x0E.0\\n0x0F.33\\n\\n0x1F.0\\n0x20.8\\n0x21.0\\n0x22.0\\n0x23.18\\n0x24.0\\n0x25.0\\n0x26.0\\n0x27.0\\n0x28.0\\n0x29.0\\n0x2A.0\\n0x2B.0\\n0x2C.0\\n0x2D.0\\n0x2E.0\\n0x2F.20\\n0x30.0\\n0x31.0\\n0x32.0\\n0x33.0\\n\\n0x38.0\\n0x39.0\\n0x3A.0\\n0x3B.0\\n0x3C.0\\n0x3D.0\\n';\nconst obciRegisterQueryAccelerometerFirmwareV3 = '\\nLIS3DH Registers\\n0x07 00\\n0x08 00\\n0x09 00\\n0x0A 00\\n0x0B 00\\n0x0C 00\\n0x0D 00\\n0x0E 00\\n0x0F 33\\n\\n0x1F 00\\n0x20 08\\n0x21 00\\n0x22 00\\n0x23 18\\n0x24 00\\n0x25 00\\n0x26 00\\n0x27 00\\n0x28 00\\n0x29 00\\n0x2A 00\\n0x2B 00\\n0x2C 00\\n0x2D 00\\n0x2E 00\\n0x2F 20\\n0x30 00\\n0x31 00\\n0x32 00\\n0x33 00\\n\\n0x38 00\\n0x39 00\\n0x3A 00\\n0x3B 00\\n0x3C 00\\n0x3D 00\\n';\nconst obciRegisterQueryCyton = '\\nBoard ADS Registers\\nADS_ID, 00, 3E, 0, 0, 1, 1, 1, 1, 1, 0\\nCONFIG1, 01, 96, 1, 0, 0, 1, 0, 1, 1, 0\\nCONFIG2, 02, C0, 1, 1, 0, 0, 0, 0, 0, 0\\nCONFIG3, 03, EC, 1, 1, 1, 0, 1, 1, 0, 0\\nLOFF, 04, 02, 0, 0, 0, 0, 0, 0, 1, 0\\nCH1SET, 05, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH2SET, 06, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH3SET, 07, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH4SET, 08, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH5SET, 09, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH6SET, 0A, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH7SET, 0B, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH8SET, 0C, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nBIAS_SENSP, 0D, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nBIAS_SENSN, 0E, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nLOFF_SENSP, 0F, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_SENSN, 10, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_FLIP, 11, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATP, 12, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATN, 13, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nGPIO, 14, 0F, 0, 0, 0, 0, 1, 1, 1, 1\\nMISC1, 15, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nMISC2, 16, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nCONFIG4, 17, 00, 0, 0, 0, 0, 0, 0, 0, 0\\n';\nconst obciRegisterQueryCytonDaisy = '\\nDaisy ADS Registers\\nADS_ID, 00, 3E, 0, 0, 1, 1, 1, 1, 1, 0\\nCONFIG1, 01, 96, 1, 0, 0, 1, 0, 1, 1, 0\\nCONFIG2, 02, C0, 1, 1, 0, 0, 0, 0, 0, 0\\nCONFIG3, 03, EC, 1, 1, 1, 0, 1, 1, 0, 0\\nLOFF, 04, 02, 0, 0, 0, 0, 0, 0, 1, 0\\nCH1SET, 05, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH2SET, 06, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH3SET, 07, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH4SET, 08, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH5SET, 09, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH6SET, 0A, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH7SET, 0B, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH8SET, 0C, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nBIAS_SENSP, 0D, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nBIAS_SENSN, 0E, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nLOFF_SENSP, 0F, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_SENSN, 10, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_FLIP, 11, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATP, 12, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATN, 13, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nGPIO, 14, 0F, 0, 0, 0, 0, 1, 1, 1, 1\\nMISC1, 15, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nMISC2, 16, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nCONFIG4, 17, 00, 0, 0, 0, 0, 0, 0, 0, 0\\n';\nconst obciRegisterQueryNameMISC1 = 'MISC1';\nconst obciRegisterQueryNameBIASSENSP = 'BIAS_SENSP';\nconst obciRegisterQueryNameCHnSET = ['CH1SET', 'CH2SET', 'CH3SET', 'CH4SET', 'CH5SET', 'CH6SET', 'CH7SET', 'CH8SET'];\nconst obciRegisterQuerySizeCytonFirmwareV1 = obciRegisterQueryCyton.length + obciRegisterQueryAccelerometerFirmwareV1.length;\nconst obciRegisterQuerySizeCytonDaisyFirmwareV1 = obciRegisterQueryCyton.length + obciRegisterQueryCytonDaisy.length + obciRegisterQueryAccelerometerFirmwareV1.length;\nconst obciRegisterQuerySizeCytonFirmwareV3 = obciRegisterQueryCyton.length + obciRegisterQueryAccelerometerFirmwareV3.length;\nconst obciRegisterQuerySizeCytonDaisyFirmwareV3 = obciRegisterQueryCyton.length + obciRegisterQueryCytonDaisy.length + obciRegisterQueryAccelerometerFirmwareV3.length;\n\nconst constantsModule = {\n  /** Turning channels off */\n  OBCIChannelOff1: obciChannelOff1,\n  OBCIChannelOff2: obciChannelOff2,\n  OBCIChannelOff3: obciChannelOff3,\n  OBCIChannelOff4: obciChannelOff4,\n  OBCIChannelOff5: obciChannelOff5,\n  OBCIChannelOff6: obciChannelOff6,\n  OBCIChannelOff7: obciChannelOff7,\n  OBCIChannelOff8: obciChannelOff8,\n  OBCIChannelOff9: obciChannelOff9,\n  OBCIChannelOff10: obciChannelOff10,\n  OBCIChannelOff11: obciChannelOff11,\n  OBCIChannelOff12: obciChannelOff12,\n  OBCIChannelOff13: obciChannelOff13,\n  OBCIChannelOff14: obciChannelOff14,\n  OBCIChannelOff15: obciChannelOff15,\n  OBCIChannelOff16: obciChannelOff16,\n  /**\n  * Purpose: To get the proper command to turn a channel off\n  * @param channelNumber - A number (1-16) of the desired channel\n  * @returns {Promise}\n  */\n  commandChannelOff: function (channelNumber) {\n    return new Promise(function (resolve, reject) {\n      switch (channelNumber) {\n        case 1:\n          resolve(obciChannelOff1);\n          break;\n        case 2:\n          resolve(obciChannelOff2);\n          break;\n        case 3:\n          resolve(obciChannelOff3);\n          break;\n        case 4:\n          resolve(obciChannelOff4);\n          break;\n        case 5:\n          resolve(obciChannelOff5);\n          break;\n        case 6:\n          resolve(obciChannelOff6);\n          break;\n        case 7:\n          resolve(obciChannelOff7);\n          break;\n        case 8:\n          resolve(obciChannelOff8);\n          break;\n        case 9:\n          resolve(obciChannelOff9);\n          break;\n        case 10:\n          resolve(obciChannelOff10);\n          break;\n        case 11:\n          resolve(obciChannelOff11);\n          break;\n        case 12:\n          resolve(obciChannelOff12);\n          break;\n        case 13:\n          resolve(obciChannelOff13);\n          break;\n        case 14:\n          resolve(obciChannelOff14);\n          break;\n        case 15:\n          resolve(obciChannelOff15);\n          break;\n        case 16:\n          resolve(obciChannelOff16);\n          break;\n        default:\n          reject(Error('Error [commandChannelOff]: Invalid Channel Number'));\n          break;\n      }\n    });\n  },\n  /** Turning channels on */\n  OBCIChannelOn1: obciChannelOn1,\n  OBCIChannelOn2: obciChannelOn2,\n  OBCIChannelOn3: obciChannelOn3,\n  OBCIChannelOn4: obciChannelOn4,\n  OBCIChannelOn5: obciChannelOn5,\n  OBCIChannelOn6: obciChannelOn6,\n  OBCIChannelOn7: obciChannelOn7,\n  OBCIChannelOn8: obciChannelOn8,\n  OBCIChannelOn9: obciChannelOn9,\n  OBCIChannelOn10: obciChannelOn10,\n  OBCIChannelOn11: obciChannelOn11,\n  OBCIChannelOn12: obciChannelOn12,\n  OBCIChannelOn13: obciChannelOn13,\n  OBCIChannelOn14: obciChannelOn14,\n  OBCIChannelOn15: obciChannelOn15,\n  OBCIChannelOn16: obciChannelOn16,\n  commandChannelOn: function (channelNumber) {\n    return new Promise(function (resolve, reject) {\n      switch (channelNumber) {\n        case 1:\n          resolve(obciChannelOn1);\n          break;\n        case 2:\n          resolve(obciChannelOn2);\n          break;\n        case 3:\n          resolve(obciChannelOn3);\n          break;\n        case 4:\n          resolve(obciChannelOn4);\n          break;\n        case 5:\n          resolve(obciChannelOn5);\n          break;\n        case 6:\n          resolve(obciChannelOn6);\n          break;\n        case 7:\n          resolve(obciChannelOn7);\n          break;\n        case 8:\n          resolve(obciChannelOn8);\n          break;\n        case 9:\n          resolve(obciChannelOn9);\n          break;\n        case 10:\n          resolve(obciChannelOn10);\n          break;\n        case 11:\n          resolve(obciChannelOn11);\n          break;\n        case 12:\n          resolve(obciChannelOn12);\n          break;\n        case 13:\n          resolve(obciChannelOn13);\n          break;\n        case 14:\n          resolve(obciChannelOn14);\n          break;\n        case 15:\n          resolve(obciChannelOn15);\n          break;\n        case 16:\n          resolve(obciChannelOn16);\n          break;\n        default:\n          reject(Error('Error [commandChannelOn]: Invalid Channel Number'));\n          break;\n      }\n    });\n  },\n  /** Test Signal Control Commands */\n  OBCITestSignalConnectToDC: obciTestSignalConnectToDC,\n  OBCITestSignalConnectToGround: obciTestSignalConnectToGround,\n  OBCITestSignalConnectToPulse1xFast: obciTestSignalConnectToPulse1xFast,\n  OBCITestSignalConnectToPulse1xSlow: obciTestSignalConnectToPulse1xSlow,\n  OBCITestSignalConnectToPulse2xFast: obciTestSignalConnectToPulse2xFast,\n  OBCITestSignalConnectToPulse2xSlow: obciTestSignalConnectToPulse2xSlow,\n  getTestSignalCommand: signal => {\n    return new Promise((resolve, reject) => {\n      switch (signal) {\n        case 'dc':\n          resolve(obciTestSignalConnectToDC);\n          break;\n        case 'ground':\n          resolve(obciTestSignalConnectToGround);\n          break;\n        case 'pulse1xFast':\n          resolve(obciTestSignalConnectToPulse1xFast);\n          break;\n        case 'pulse1xSlow':\n          resolve(obciTestSignalConnectToPulse1xSlow);\n          break;\n        case 'pulse2xFast':\n          resolve(obciTestSignalConnectToPulse2xFast);\n          break;\n        case 'pulse2xSlow':\n          resolve(obciTestSignalConnectToPulse2xSlow);\n          break;\n        case 'none':\n          resolve(obciChannelDefaultAllSet);\n          break;\n        default:\n          reject(Error('Invalid selection! Check your spelling.'));\n          break;\n      }\n    });\n  },\n  /** Channel Setting Commands */\n  OBCIChannelCmdADCNormal: obciChannelCmdADCNormal,\n  OBCIChannelCmdADCShorted: obciChannelCmdADCShorted,\n  OBCIChannelCmdADCBiasDRP: obciChannelCmdADCBiasDRP,\n  OBCIChannelCmdADCBiasDRN: obciChannelCmdADCBiasDRN,\n  OBCIChannelCmdADCBiasMethod: obciChannelCmdADCBiasMethod,\n  OBCIChannelCmdADCMVDD: obciChannelCmdADCMVDD,\n  OBCIChannelCmdADCTemp: obciChannelCmdADCTemp,\n  OBCIChannelCmdADCTestSig: obciChannelCmdADCTestSig,\n  OBCIChannelCmdBiasInclude: obciChannelCmdBiasInclude,\n  OBCIChannelCmdBiasRemove: obciChannelCmdBiasRemove,\n  OBCIChannelCmdChannel1: obciChannelCmdChannel1,\n  OBCIChannelCmdChannel2: obciChannelCmdChannel2,\n  OBCIChannelCmdChannel3: obciChannelCmdChannel3,\n  OBCIChannelCmdChannel4: obciChannelCmdChannel4,\n  OBCIChannelCmdChannel5: obciChannelCmdChannel5,\n  OBCIChannelCmdChannel6: obciChannelCmdChannel6,\n  OBCIChannelCmdChannel7: obciChannelCmdChannel7,\n  OBCIChannelCmdChannel8: obciChannelCmdChannel8,\n  OBCIChannelCmdChannel9: obciChannelCmdChannel9,\n  OBCIChannelCmdChannel10: obciChannelCmdChannel10,\n  OBCIChannelCmdChannel11: obciChannelCmdChannel11,\n  OBCIChannelCmdChannel12: obciChannelCmdChannel12,\n  OBCIChannelCmdChannel13: obciChannelCmdChannel13,\n  OBCIChannelCmdChannel14: obciChannelCmdChannel14,\n  OBCIChannelCmdChannel15: obciChannelCmdChannel15,\n  OBCIChannelCmdChannel16: obciChannelCmdChannel16,\n  commandChannelForCmd,\n  OBCIChannelCmdGain1: obciChannelCmdGain1,\n  OBCIChannelCmdGain2: obciChannelCmdGain2,\n  OBCIChannelCmdGain4: obciChannelCmdGain4,\n  OBCIChannelCmdGain6: obciChannelCmdGain6,\n  OBCIChannelCmdGain8: obciChannelCmdGain8,\n  OBCIChannelCmdGain12: obciChannelCmdGain12,\n  OBCIChannelCmdGain24: obciChannelCmdGain24,\n  commandForGain,\n  gainForCommand,\n  OBCIChannelCmdLatch: obciChannelCmdLatch,\n  OBCIChannelCmdPowerOff: obciChannelCmdPowerOff,\n  OBCIChannelCmdPowerOn: obciChannelCmdPowerOn,\n  OBCIChannelCmdSet: obciChannelCmdSet,\n  OBCIChannelCmdSRB1Connect: obciChannelCmdSRB1Connect,\n  OBCIChannelCmdSRB1Diconnect: obciChannelCmdSRB1Diconnect,\n  OBCIChannelCmdSRB2Connect: obciChannelCmdSRB2Connect,\n  OBCIChannelCmdSRB2Diconnect: obciChannelCmdSRB2Diconnect,\n  /** Channel Settings Object */\n  channelSettingsObjectDefault,\n  /**\n   * @param numberOfChannels {Number}\n   * @returns {Array}\n   */\n  channelSettingsArrayInit: numberOfChannels => {\n    var newChannelSettingsArray = [];\n    for (var i = 0; i < numberOfChannels; i++) {\n      newChannelSettingsArray.push(channelSettingsObjectDefault(i));\n    }\n    return newChannelSettingsArray;\n  },\n  /** Channel Setting Helper Strings */\n  OBCIStringADCNormal: obciStringADCNormal,\n  OBCIStringADCShorted: obciStringADCShorted,\n  OBCIStringADCBiasMethod: obciStringADCBiasMethod,\n  OBCIStringADCMvdd: obciStringADCMvdd,\n  OBCIStringADCTemp: obciStringADCTemp,\n  OBCIStringADCTestSig: obciStringADCTestSig,\n  OBCIStringADCBiasDrp: obciStringADCBiasDrp,\n  OBCIStringADCBiasDrn: obciStringADCBiasDrn,\n  /**\n  * @description To convert a string like 'normal' to the correct command (i.e. '1')\n  * @param adcString\n  * @returns {Promise}\n  * @author AJ Keller (@pushtheworldllc)\n  */\n  commandForADCString,\n  inputTypeForCommand,\n  /** Default Channel Settings */\n  OBCIChannelDefaultAllSet: obciChannelDefaultAllSet,\n  OBCIChannelDefaultAllGet: obciChannelDefaultAllGet,\n  /** LeadOff Impedance Commands */\n  OBCIChannelImpedanceLatch: obciChannelImpedanceLatch,\n  OBCIChannelImpedanceSet: obciChannelImpedanceSet,\n  OBCIChannelImpedanceTestSignalApplied: obciChannelImpedanceTestSignalApplied,\n  OBCIChannelImpedanceTestSignalAppliedNot: obciChannelImpedanceTestSignalAppliedNot,\n  /** SD card Commands */\n  OBCISDLogForHour1: obciSDLogForHour1,\n  OBCISDLogForHour2: obciSDLogForHour2,\n  OBCISDLogForHour4: obciSDLogForHour4,\n  OBCISDLogForHour12: obciSDLogForHour12,\n  OBCISDLogForHour24: obciSDLogForHour24,\n  OBCISDLogForMin5: obciSDLogForMin5,\n  OBCISDLogForMin15: obciSDLogForMin15,\n  OBCISDLogForMin30: obciSDLogForMin30,\n  OBCISDLogForSec14: obciSDLogForSec14,\n  OBCISDLogStop: obciSDLogStop,\n  /** SD Card String Commands */\n  OBCIStringSDHour1: obciStringSDHour1,\n  OBCIStringSDHour2: obciStringSDHour2,\n  OBCIStringSDHour4: obciStringSDHour4,\n  OBCIStringSDHour12: obciStringSDHour12,\n  OBCIStringSDHour24: obciStringSDHour24,\n  OBCIStringSDMin5: obciStringSDMin5,\n  OBCIStringSDMin15: obciStringSDMin15,\n  OBCIStringSDMin30: obciStringSDMin30,\n  OBCIStringSDSec14: obciStringSDSec14,\n  /**\n  * @description Converts a sd string into the proper setting.\n  * @param stringCommand {String} - The length of time you want to record to the SD for.\n  * @returns {Promise} The command to send to the Board, returns an error on improper `stringCommand`\n  */\n  sdSettingForString: stringCommand => {\n    return new Promise((resolve, reject) => {\n      switch (stringCommand) {\n        case obciStringSDHour1:\n          resolve(obciSDLogForHour1);\n          break;\n        case obciStringSDHour2:\n          resolve(obciSDLogForHour2);\n          break;\n        case obciStringSDHour4:\n          resolve(obciSDLogForHour4);\n          break;\n        case obciStringSDHour12:\n          resolve(obciSDLogForHour12);\n          break;\n        case obciStringSDHour24:\n          resolve(obciSDLogForHour24);\n          break;\n        case obciStringSDMin5:\n          resolve(obciSDLogForMin5);\n          break;\n        case obciStringSDMin15:\n          resolve(obciSDLogForMin15);\n          break;\n        case obciStringSDMin30:\n          resolve(obciSDLogForMin30);\n          break;\n        case obciStringSDSec14:\n          resolve(obciSDLogForSec14);\n          break;\n        default:\n          reject(Error(TypeError));\n          break;\n      }\n    });\n  },\n  /** Stream Data Commands */\n  OBCIStreamStart: obciStreamStart,\n  OBCIStreamStop: obciStreamStop,\n  /** Accel enable/disable commands */\n  OBCIAccelStart: obciAccelStart,\n  OBCIAccelStop: obciAccelStop,\n  /** Miscellaneous */\n  OBCIMiscQueryRegisterSettings: obciMiscQueryRegisterSettings,\n  OBCIMiscQueryRegisterSettingsChannel1: obciMiscQueryRegisterSettingsChannel1,\n  OBCIMiscQueryRegisterSettingsChannel2: obciMiscQueryRegisterSettingsChannel2,\n  OBCIMiscQueryRegisterSettingsChannel3: obciMiscQueryRegisterSettingsChannel3,\n  OBCIMiscQueryRegisterSettingsChannel4: obciMiscQueryRegisterSettingsChannel4,\n  OBCIMiscQueryRegisterSettingsChannel5: obciMiscQueryRegisterSettingsChannel5,\n  OBCIMiscQueryRegisterSettingsChannel6: obciMiscQueryRegisterSettingsChannel6,\n  OBCIMiscQueryRegisterSettingsChannel7: obciMiscQueryRegisterSettingsChannel7,\n  OBCIMiscQueryRegisterSettingsChannel8: obciMiscQueryRegisterSettingsChannel8,\n  channelSettingsKeyForChannel: channelNumber => {\n    return new Promise((resolve, reject) => {\n      switch (channelNumber) {\n        case 1:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel1));\n          break;\n        case 2:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel2));\n          break;\n        case 3:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel3));\n          break;\n        case 4:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel4));\n          break;\n        case 5:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel5));\n          break;\n        case 6:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel6));\n          break;\n        case 7:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel7));\n          break;\n        case 8:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel8));\n          break;\n        default:\n          reject(Error('Invalid channel number'));\n          break;\n      }\n    });\n  },\n  OBCIMiscSoftReset: obciMiscSoftReset,\n  /** 16 Channel Commands */\n  OBCIChannelMaxNumber8: obciChannelMaxNumber8,\n  OBCIChannelMaxNumber16: obciChannelMaxNumber16,\n  OBCIChannelMaxNumber8NoDaisyToRemove: obciChannelMaxNumber8NoDaisyToRemove,\n  OBCIChannelMaxNumber8SuccessDaisyRemoved: obciChannelMaxNumber8SuccessDaisyRemoved,\n  OBCIChannelMaxNumber16DaisyAlreadyAttached: obciChannelMaxNumber16DaisyAlreadyAttached,\n  OBCIChannelMaxNumber16DaisyAttached: obciChannelMaxNumber16DaisyAttached,\n  OBCIChannelMaxNumber16NoDaisyAttached: obciChannelMaxNumber16NoDaisyAttached,\n  /** Filters */\n  OBCIFilterDisable: obciFilterDisable,\n  OBCIFilterEnable: obciFilterEnable,\n  /** Triggers */\n  OBCITrigger: obciTrigger,\n  /** Possible number of channels */\n  OBCINumberOfChannelsCyton: obciNumberOfChannelsCyton,\n  OBCINumberOfChannelsCytonBLE: obciNumberOfChannelsCytonBLE,\n  OBCINumberOfChannelsDaisy: obciNumberOfChannelsDaisy,\n  OBCINumberOfChannelsDefault: obciNumberOfChannelsDefault,\n  OBCINumberOfChannelsGanglion: obciNumberOfChannelsGanglion,\n  /** Possible OpenBCI board types */\n  OBCIBoardCyton: obciBoardCyton,\n  OBCIBoardCytonBLE: obciBoardCytonBLE,\n  OBCIBoardDaisy: obciBoardDaisy,\n  OBCIBoardDefault: obciBoardDefault,\n  OBCIBoardGanglion: obciBoardGanglion,\n  OBCIBoardNone: obciBoardNone,\n  numberOfChannelsForBoardType: boardType => {\n    switch (boardType) {\n      case obciBoardDaisy:\n        return obciNumberOfChannelsDaisy;\n      case obciBoardGanglion:\n        return obciNumberOfChannelsGanglion;\n      case obciBoardNone:\n        return 0;\n      case obciBoardCytonBLE:\n        return obciNumberOfChannelsCytonBLE;\n      case obciBoardCyton:\n      default:\n        return obciNumberOfChannelsDefault;\n    }\n  },\n  boardTypeForNumberOfChannels: numberOfChannels => {\n    switch (numberOfChannels) {\n      case obciNumberOfChannelsDaisy:\n        return obciBoardDaisy;\n      case obciNumberOfChannelsGanglion:\n        return obciBoardGanglion;\n      case 0:\n        return obciBoardNone;\n      case obciNumberOfChannelsCytonBLE:\n        return obciBoardCytonBLE;\n      case obciNumberOfChannelsDefault:\n      default:\n        return obciBoardCyton;\n    }\n  },\n  /** Possible Sample Rates */\n  OBCISampleRate1000: obciSampleRate1000,\n  OBCISampleRate125: obciSampleRate125,\n  OBCISampleRate12800: obciSampleRate12800,\n  OBCISampleRate1600: obciSampleRate1600,\n  OBCISampleRate16000: obciSampleRate16000,\n  OBCISampleRate200: obciSampleRate200,\n  OBCISampleRate2000: obciSampleRate2000,\n  OBCISampleRate250: obciSampleRate250,\n  OBCISampleRate25600: obciSampleRate25600,\n  OBCISampleRate3200: obciSampleRate3200,\n  OBCISampleRate400: obciSampleRate400,\n  OBCISampleRate4000: obciSampleRate4000,\n  OBCISampleRate500: obciSampleRate500,\n  OBCISampleRate6400: obciSampleRate6400,\n  OBCISampleRate800: obciSampleRate800,\n  OBCISampleRate8000: obciSampleRate8000,\n  /** Max sample number */\n  OBCISampleNumberMax: obciSampleNumberMax,\n  /** Packet Size */\n  OBCIPacketSize: obciPacketSize,\n  OBCIPacketSizeBLECyton: obciPacketSizeBLECyton,\n  OBCIPacketSizeBLERaw: obciPacketSizeBLERaw,\n  /** Notable Bytes */\n  OBCIByteStart: obciByteStart,\n  OBCIByteStop: obciByteStop,\n  /** Errors */\n  OBCIErrorInvalidByteLength: errorInvalidByteLength,\n  OBCIErrorInvalidByteStart: errorInvalidByteStart,\n  OBCIErrorInvalidByteStop: errorInvalidByteStop,\n  OBCIErrorInvalidData: errorInvalidData,\n  OBCIErrorInvalidType: errorInvalidType,\n  OBCIErrorMissingRegisterSetting: errorMissingRegisterSetting,\n  OBCIErrorMissingRequiredProperty: errorMissingRequiredProperty,\n  OBCIErrorNobleAlreadyScanning: errorNobleAlreadyScanning,\n  OBCIErrorNobleNotAlreadyScanning: errorNobleNotAlreadyScanning,\n  OBCIErrorNobleNotInPoweredOnState: errorNobleNotInPoweredOnState,\n  OBCIErrorTimeSyncIsNull: errorTimeSyncIsNull,\n  OBCIErrorTimeSyncNoComma: errorTimeSyncNoComma,\n  OBCIErrorUndefinedOrNullInput: errorUndefinedOrNullInput,\n  /** Max Master Buffer Size */\n  OBCIMasterBufferSize: obciMasterBufferSize,\n  /** Impedance Calculation Variables */\n  OBCILeadOffDriveInAmps: obciLeadOffDriveInAmps,\n  OBCILeadOffFrequencyHz: obciLeadOffFrequencyHz,\n  /** Channel Setter Maker */\n  getChannelSetter: channelSetter,\n  /** Impedance Setter Maker */\n  getImpedanceSetter: impedanceSetter,\n  /** Sample Rate Setter Maker */\n  getSampleRateSetter: sampleRateSetter,\n  /** Board Mode Setter Maker */\n  getBoardModeSetter: boardModeSetter,\n  /** Command send delay */\n  OBCIWriteIntervalDelayMSLong: obciWriteIntervalDelayMSLong,\n  OBCIWriteIntervalDelayMSNone: obciWriteIntervalDelayMSNone,\n  OBCIWriteIntervalDelayMSShort: obciWriteIntervalDelayMSShort,\n  /** Sync Clocks */\n  OBCISyncTimeSent: obciSyncTimeSent,\n  OBCISyncTimeSet: obciSyncTimeSet,\n  /** Radio Key */\n  OBCIRadioKey: obciRadioKey,\n  /** Radio Commands */\n  OBCIRadioCmdChannelGet: obciRadioCmdChannelGet,\n  OBCIRadioCmdChannelSet: obciRadioCmdChannelSet,\n  OBCIRadioCmdChannelSetOverride: obciRadioCmdChannelSetOverride,\n  OBCIRadioCmdPollTimeGet: obciRadioCmdPollTimeGet,\n  OBCIRadioCmdPollTimeSet: obciRadioCmdPollTimeSet,\n  OBCIRadioCmdBaudRateSetDefault: obciRadioCmdBaudRateSetDefault,\n  OBCIRadioCmdBaudRateSetFast: obciRadioCmdBaudRateSetFast,\n  OBCIRadioCmdSystemStatus: obciRadioCmdSystemStatus,\n  /** Impedance */\n  OBCIImpedanceTextBad: obciImpedanceTextBad,\n  OBCIImpedanceTextGood: obciImpedanceTextGood,\n  OBCIImpedanceTextInit: obciImpedanceTextInit,\n  OBCIImpedanceTextOk: obciImpedanceTextOk,\n  OBCIImpedanceTextNone: obciImpedanceTextNone,\n  OBCIImpedanceThresholdBadMax: obciImpedanceThresholdBadMax,\n  OBCIImpedanceSeriesResistor: obciImpedanceSeriesResistor,\n  getTextForRawImpedance: value => {\n    if (value > obciImpedanceThresholdGoodMin && value < obciImpedanceThresholdGoodMax) {\n      return obciImpedanceTextGood;\n    } else if (value > obciImpedanceThresholdOkMin && value < obciImpedanceThresholdOkMax) {\n      return obciImpedanceTextOk;\n    } else if (value > obciImpedanceThresholdBadMin && value < obciImpedanceThresholdBadMax) {\n      return obciImpedanceTextBad;\n    } else {\n      return obciImpedanceTextNone;\n    }\n  },\n  /** Simulator */\n  OBCISimulatorPortName: obciSimulatorPortName,\n  /**\n  * Stream packet types/codes\n  */\n  OBCIStreamPacketStandardAccel: obciStreamPacketStandardAccel,\n  OBCIStreamPacketStandardRawAux: obciStreamPacketStandardRawAux,\n  OBCIStreamPacketUserDefinedType: obciStreamPacketUserDefinedType,\n  OBCIStreamPacketAccelTimeSyncSet: obciStreamPacketAccelTimeSyncSet,\n  OBCIStreamPacketAccelTimeSynced: obciStreamPacketAccelTimeSynced,\n  OBCIStreamPacketRawAuxTimeSyncSet: obciStreamPacketRawAuxTimeSyncSet,\n  OBCIStreamPacketRawAuxTimeSynced: obciStreamPacketRawAuxTimeSynced,\n  OBCIStreamPacketImpedance: obciStreamPacketImpedance,\n  /** fun funcs */\n  isNumber,\n  isBoolean,\n  isString,\n  isUndefined,\n  isNull,\n  /** OpenBCI V3 Standard Packet Positions */\n  OBCIPacketPositionStartByte: obciPacketPositionStartByte,\n  OBCIPacketPositionStopByte: obciPacketPositionStopByte,\n  OBCIPacketPositionStartAux: obciPacketPositionStartAux,\n  OBCIPacketPositionStopAux: obciPacketPositionStopAux,\n  OBCIPacketPositionChannelDataStart: obciPacketPositionChannelDataStart,\n  OBCIPacketPositionChannelDataStop: obciPacketPositionChannelDataStop,\n  OBCIPacketPositionSampleNumber: obciPacketPositionSampleNumber,\n  OBCIPacketPositionTimeSyncAuxStart: obciPacketPositionTimeSyncAuxStart,\n  OBCIPacketPositionTimeSyncAuxStop: obciPacketPositionTimeSyncAuxStop,\n  OBCIPacketPositionTimeSyncTimeStart: obciPacketPositionTimeSyncTimeStart,\n  OBCIPacketPositionTimeSyncTimeStop: obciPacketPositionTimeSyncTimeStop,\n  /** Possible Simulator Line Noise injections */\n  OBCISimulatorLineNoiseHz60: obciSimulatorLineNoiseHz60,\n  OBCISimulatorLineNoiseHz50: obciSimulatorLineNoiseHz50,\n  OBCISimulatorLineNoiseNone: obciSimulatorLineNoiseNone,\n  /** Possible Simulator Fragmentation modes */\n  OBCISimulatorFragmentationRandom: obciSimulatorFragmentationRandom,\n  OBCISimulatorFragmentationFullBuffers: obciSimulatorFragmentationFullBuffers,\n  OBCISimulatorFragmentationOneByOne: obciSimulatorFragmentationOneByOne,\n  OBCISimulatorFragmentationNone: obciSimulatorFragmentationNone,\n  /** Firmware version indicator */\n  OBCIFirmwareV1: obciFirmwareV1,\n  OBCIFirmwareV2: obciFirmwareV2,\n  OBCIFirmwareV3: obciFirmwareV3,\n  /** Time synced accel packet */\n  OBCIAccelAxisX: obciAccelAxisX,\n  OBCIAccelAxisY: obciAccelAxisY,\n  OBCIAccelAxisZ: obciAccelAxisZ,\n  /** Time from board */\n  OBCIStreamPacketTimeByteSize: obciStreamPacketTimeByteSize,\n  /** Parse */\n  OBCIParseDaisy: obciParseDaisy,\n  OBCIParseFailure: obciParseFailure,\n  OBCIParseFirmware: obciParseFirmware,\n  OBCIParseEOT: obciParseEOT,\n  OBCIParseSuccess: obciParseSuccess,\n  /** Used in parsing incoming serial data */\n  OBCIParsingChannelSettings: obciParsingChannelSettings,\n  OBCIParsingEOT: obciParsingEOT,\n  OBCIParsingNormal: obciParsingNormal,\n  OBCIParsingReset: obciParsingReset,\n  OBCIParsingTimeSyncSent: obciParsingTimeSyncSent,\n  /** Timeouts */\n  OBCITimeoutProcessBytes: obciTimeoutProcessBytes,\n  /** Simulator Board Configurations */\n  OBCISimulatorRawAux: obciSimulatorRawAux,\n  OBCISimulatorStandard: obciSimulatorStandard,\n  /** Radio Channel Limits */\n  OBCIRadioChannelMax: obciRadioChannelMax,\n  OBCIRadioChannelMin: obciRadioChannelMin,\n  OBCIRadioPollTimeMax: obciRadioPollTimeMax,\n  OBCIRadioPollTimeMin: obciRadioPollTimeMin,\n  /** Time sync stuff */\n  OBCITimeSyncArraySize: obciTimeSyncArraySize,\n  OBCITimeSyncMultiplierWithSyncConf: obciTimeSyncMultiplierWithSyncConf,\n  OBCITimeSyncMultiplierWithoutSyncConf: obciTimeSyncMultiplierWithoutSyncConf,\n  OBCITimeSyncThresholdTransFailureMS: obciTimeSyncThresholdTransFailureMS,\n  /** Set board mode */\n  OBCIBoardModeSet: obciBoardModeSet,\n  OBCIBoardModeCmdDefault: obciBoardModeCmdDefault,\n  OBCIBoardModeCmdDebug: obciBoardModeCmdDebug,\n  OBCIBoardModeCmdAnalog: obciBoardModeCmdAnalog,\n  OBCIBoardModeCmdDigital: obciBoardModeCmdDigital,\n  OBCIBoardModeCmdGetCur: obciBoardModeCmdGetCur,\n  OBCIBoardModeAnalog: obciBoardModeAnalog,\n  OBCIBoardModeDefault: obciBoardModeDefault,\n  OBCIBoardModeDebug: obciBoardModeDebug,\n  OBCIBoardModeDigital: obciBoardModeDigital,\n\n  /** Set sample rate */\n  OBCISampleRateSet: obciSampleRateSet,\n  OBCISampleRateCmdCyton16000: obciSampleRateCmdCyton16000,\n  OBCISampleRateCmdCyton8000: obciSampleRateCmdCyton8000,\n  OBCISampleRateCmdCyton4000: obciSampleRateCmdCyton4000,\n  OBCISampleRateCmdCyton2000: obciSampleRateCmdCyton2000,\n  OBCISampleRateCmdCyton1000: obciSampleRateCmdCyton1000,\n  OBCISampleRateCmdCyton500: obciSampleRateCmdCyton500,\n  OBCISampleRateCmdCyton250: obciSampleRateCmdCyton250,\n  OBCISampleRateCmdGang25600: obciSampleRateCmdGang25600,\n  OBCISampleRateCmdGang12800: obciSampleRateCmdGang12800,\n  OBCISampleRateCmdGang6400: obciSampleRateCmdGang6400,\n  OBCISampleRateCmdGang3200: obciSampleRateCmdGang3200,\n  OBCISampleRateCmdGang1600: obciSampleRateCmdGang1600,\n  OBCISampleRateCmdGang800: obciSampleRateCmdGang800,\n  OBCISampleRateCmdGang400: obciSampleRateCmdGang400,\n  OBCISampleRateCmdGang200: obciSampleRateCmdGang200,\n  OBCISampleRateCmdGetCur: obciSampleRateCmdaGetCur,\n\n  /** Wifi Stuff */\n  OBCIWifiAttach: obciWifiAttach,\n  OBCIWifiRemove: obciWifiRemove,\n  OBCIWifiReset: obciWifiReset,\n  OBCIWifiStatus: obciWifiStatus,\n  /** Baud Rates */\n  OBCIRadioBaudRateDefault: obciRadioBaudRateDefault,\n  OBCIRadioBaudRateDefaultStr: obciRadioBaudRateDefaultStr,\n  OBCIRadioBaudRateFast: obciRadioBaudRateFast,\n  OBCIRadioBaudRateFastStr: obciRadioBaudRateFastStr,\n  /** Emitters */\n  OBCIEmitterAccelerometer: obciEmitterAccelerometer,\n  OBCIEmitterBlePoweredUp: obciEmitterBlePoweredUp,\n  OBCIEmitterClose: obciEmitterClose,\n  OBCIEmitterDroppedPacket: obciEmitterDroppedPacket,\n  OBCIEmitterEot: obciEmitterEot,\n  OBCIEmitterError: obciEmitterError,\n  OBCIEmitterGanglionFound: obciEmitterGanglionFound,\n  OBCIEmitterHardSet: obciEmitterHardSet,\n  OBCIEmitterImpedance: obciEmitterImpedance,\n  OBCIEmitterImpedanceArray: obciEmitterImpedanceArray,\n  OBCIEmitterMessage: obciEmitterMessage,\n  OBCIEmitterQuery: obciEmitterQuery,\n  OBCIEmitterRawDataPacket: obciEmitterRawDataPacket,\n  OBCIEmitterReady: obciEmitterReady,\n  OBCIEmitterRFduino: obciEmitterRFduino,\n  OBCIEmitterSample: obciEmitterSample,\n  OBCIEmitterScanStopped: obciEmitterScanStopped,\n  OBCIEmitterSynced: obciEmitterSynced,\n  OBCIEmitterWifiShield: obciEmitterWifiShield,\n  /** Emitters */\n  /** Accel packets */\n  OBCIGanglionAccelAxisX: obciGanglionAccelAxisX,\n  OBCIGanglionAccelAxisY: obciGanglionAccelAxisY,\n  OBCIGanglionAccelAxisZ: obciGanglionAccelAxisZ,\n  /** Ganglion */\n  OBCIGanglionBleSearchTime: obciGanglionBleSearchTime,\n  OBCIGanglionByteIdUncompressed: obciGanglionByteIdUncompressed,\n  OBCIGanglionByteId18Bit: obciGanglionByteId18Bit,\n  OBCIGanglionByteId19Bit: obciGanglionByteId19Bit,\n  OBCIGanglionByteIdImpedanceChannel1: obciGanglionByteIdImpedanceChannel1,\n  OBCIGanglionByteIdImpedanceChannel2: obciGanglionByteIdImpedanceChannel2,\n  OBCIGanglionByteIdImpedanceChannel3: obciGanglionByteIdImpedanceChannel3,\n  OBCIGanglionByteIdImpedanceChannel4: obciGanglionByteIdImpedanceChannel4,\n  OBCIGanglionByteIdImpedanceChannelReference: obciGanglionByteIdImpedanceChannelReference,\n  OBCIGanglionByteIdMultiPacket: obciGanglionByteIdMultiPacket,\n  OBCIGanglionByteIdMultiPacketStop: obciGanglionByteIdMultiPacketStop,\n  OBCIGanglionMCP3912Gain: obciGanglionMCP3912Gain, // assumed gain setting for MCP3912.  NEEDS TO BE ADJUSTABLE JM\n  OBCIGanglionMCP3912Vref: obciGanglionMCP3912Vref, // reference voltage for ADC in MCP3912 set in hardware\n  OBCIGanglionPacketSize: obciGanglionPacketSize,\n  OBCIGanglionPacket18Bit: obciGanglionPacket18Bit,\n  OBCIGanglionPacket19Bit: obciGanglionPacket19Bit,\n  OBCIGanglionPrefix: obciGanglionPrefix,\n  OBCIGanglionSamplesPerPacket: obciGanglionSamplesPerPacket,\n  OBCIGanglionSyntheticDataEnable: obciGanglionSyntheticDataEnable,\n  OBCIGanglionSyntheticDataDisable: obciGanglionSyntheticDataDisable,\n  OBCIGanglionImpedanceStart: obciGanglionImpedanceStart,\n  OBCIGanglionImpedanceStop: obciGanglionImpedanceStop,\n  OBCIGanglionScaleFactorPerCountVolts: obciGanglionScaleFactorPerCountVolts,\n  /** Simblee */\n  SimbleeUuidService: simbleeUuidService,\n  SimbleeUuidReceive: simbleeUuidReceive,\n  SimbleeUuidSend: simbleeUuidSend,\n  SimbleeUuidDisconnect: simbleeUuidDisconnect,\n  /** RFduino BLE UUID */\n  RFduinoUuidService: rfduinoUuidService,\n  RFduinoUuidReceive: rfduinoUuidReceive,\n  RFduinoUuidSend: rfduinoUuidSend,\n  RFduinoUuidSendTwo: rfduinoUuidSendTwo,\n  /** Cyton BLE */\n  OBCICytonBLESamplesPerPacket: obciCytonBLESamplesPerPacket,\n  /** Accel scale factor */\n  OBCIGanglionAccelScaleFactor: obciGanglionAccelScaleFactor,\n  /** Noble */\n  OBCINobleEmitterPeripheralConnect: obciNobleEmitterPeripheralConnect,\n  OBCINobleEmitterPeripheralDisconnect: obciNobleEmitterPeripheralDisconnect,\n  OBCINobleEmitterPeripheralDiscover: obciNobleEmitterPeripheralDiscover,\n  OBCINobleEmitterPeripheralServicesDiscover: obciNobleEmitterPeripheralServicesDiscover,\n  OBCINobleEmitterServiceCharacteristicsDiscover: obciNobleEmitterServiceCharacteristicsDiscover,\n  OBCINobleEmitterServiceRead: obciNobleEmitterServiceRead,\n  OBCINobleEmitterDiscover: obciNobleEmitterDiscover,\n  OBCINobleEmitterScanStart: obciNobleEmitterScanStart,\n  OBCINobleEmitterScanStop: obciNobleEmitterScanStop,\n  OBCINobleEmitterStateChange: obciNobleEmitterStateChange,\n  OBCINobleStatePoweredOn: obciNobleStatePoweredOn,\n  getPeripheralLocalNames,\n  getPeripheralWithLocalName,\n  getVersionNumber,\n  isPeripheralGanglion,\n  commandSampleRateForCmdCyton,\n  commandSampleRateForCmdGanglion,\n  commandBoardModeForMode,\n  rawDataToSampleObjectDefault,\n  /** Protocols */\n  OBCIProtocolBLE: obciProtocolBLE,\n  OBCIProtocolSerial: obciProtocolSerial,\n  OBCIProtocolWifi: obciProtocolWifi,\n  /** Register Query for Cyton */\n  OBCIRegisterQueryAccelerometerFirmwareV1: obciRegisterQueryAccelerometerFirmwareV1,\n  OBCIRegisterQueryAccelerometerFirmwareV3: obciRegisterQueryAccelerometerFirmwareV3,\n  OBCIRegisterQueryCyton: obciRegisterQueryCyton,\n  OBCIRegisterQueryCytonDaisy: obciRegisterQueryCytonDaisy,\n  OBCIRegisterQueryNameMISC1: obciRegisterQueryNameMISC1,\n  OBCIRegisterQueryNameBIASSENSP: obciRegisterQueryNameBIASSENSP,\n  OBCIRegisterQueryNameCHnSET: obciRegisterQueryNameCHnSET,\n  OBCIRegisterQuerySizeCytonFirmwareV1: obciRegisterQuerySizeCytonFirmwareV1,\n  OBCIRegisterQuerySizeCytonDaisyFirmwareV1: obciRegisterQuerySizeCytonDaisyFirmwareV1,\n  OBCIRegisterQuerySizeCytonFirmwareV3: obciRegisterQuerySizeCytonFirmwareV3,\n  OBCIRegisterQuerySizeCytonDaisyFirmwareV3: obciRegisterQuerySizeCytonDaisyFirmwareV3\n};\n\n/**\n* @description To add a usability abstraction layer above channel setting commands. Due to the\n*          extensive and highly specific nature of the channel setting command chain, this\n*          will take several different human readable inputs and merge to one array filled\n*          with the correct commands, prime for sending directly to the write command.\n* @param channelNumber - Number (1-16)\n* @param powerDown - Bool (true -> OFF, false -> ON (default))\n*          turns the channel on or off\n* @param gain - Number (1,2,4,6,8,12,24(default))\n*          sets the gain for the channel\n* @param inputType - String (normal,shorted,biasMethod,mvdd,temp,testsig,biasDrp,biasDrn)\n*          selects the ADC channel input source\n* @param bias - Bool (true -> Include in bias (default), false -> remove from bias)\n*          selects to include the channel input in bias generation\n* @param srb2 - Bool (true -> Connect this input to SRB2 (default),\n*                     false -> Disconnect this input from SRB2)\n*          Select to connect (true) this channel's P input to the SRB2 pin. This closes\n*              a switch between P input and SRB2 for the given channel, and allows the\n*              P input to also remain connected to the ADC.\n* @param srb1 - Bool (true -> connect all N inputs to SRB1,\n*                     false -> Disconnect all N inputs from SRB1 (default))\n*          Select to connect (true) all channels' N inputs to SRB1. This effects all pins,\n*              and disconnects all N inputs from the ADC.\n* @returns {Promise} resolves {commandArray: array of commands to be sent,\n                               newChannelSettingsObject: an updated channel settings object\n                                                         to be stored in openBCIBoard.channelSettingsArray},\n                     rejects on bad input or no board\n*/\nfunction channelSetter(channelNumber, powerDown, gain, inputType, bias, srb2, srb1) {\n  // Used to store and assemble the commands\n  var cmdPowerDown, cmdBias, cmdSrb2, cmdSrb1;\n\n  return new Promise(function (resolve, reject) {\n    // Validate the input\n    if (!isNumber(channelNumber)) reject(Error(\"channelNumber must be of type 'number' \"));\n    if (!isBoolean(powerDown)) reject(Error(\"powerDown must be of type 'boolean' \"));\n    if (!isNumber(gain)) reject(Error(\"gain must be of type 'number' \"));\n    if (!isString(inputType)) reject(Error(\"inputType must be of type 'string' \"));\n    if (!isBoolean(bias)) reject(Error(\"bias must be of type 'boolean' \"));\n    if (!isBoolean(srb2)) reject(Error(\"srb1 must be of type 'boolean' \"));\n    if (!isBoolean(srb1)) reject(Error(\"srb2 must be of type 'boolean' \"));\n\n    // Set Channel Number\n    var p1 = commandChannelForCmd(channelNumber).catch(err => reject(err));\n\n    // Set POWER_DOWN\n    cmdPowerDown = powerDown ? obciChannelCmdPowerOff : obciChannelCmdPowerOn;\n\n    // Set Gain\n    var p2 = commandForGain(gain).catch(err => reject(err));\n\n    // Set ADC string\n    var p3 = commandForADCString(inputType).catch(err => reject(err));\n\n    // Set BIAS\n    cmdBias = bias ? obciChannelCmdBiasInclude : obciChannelCmdBiasRemove;\n\n    // Set SRB2\n    cmdSrb2 = srb2 ? obciChannelCmdSRB2Connect : obciChannelCmdSRB2Diconnect;\n\n    // Set SRB1\n    cmdSrb1 = srb1 ? obciChannelCmdSRB1Connect : obciChannelCmdSRB1Diconnect;\n\n    var newChannelSettingsObject = {\n      channelNumber: channelNumber,\n      powerDown: powerDown,\n      gain: gain,\n      inputType: inputType,\n      bias: bias,\n      srb2: srb2,\n      srb1: srb1\n    };\n\n    Promise.all([p1, p2, p3]).then(function (values) {\n      var outputArray = [obciChannelCmdSet, values[0], cmdPowerDown, values[1], values[2], cmdBias, cmdSrb2, cmdSrb1, obciChannelCmdLatch];\n      resolve({ commandArray: outputArray, newChannelSettingsObject: newChannelSettingsObject });\n    });\n  });\n}\n\n/**\n* @description To build the array of commands to send to the board to measure impedance\n* @param channelNumber\n* @param pInputApplied - Bool (true -> Test Signal Applied, false -> Test Signal Not Applied (default))\n*          applies the test signal to the P input\n* @param nInputApplied - Bool (true -> Test Signal Applied, false -> Test Signal Not Applied (default))\n*          applies the test signal to the N input\n* @returns {Promise} - fulfilled will contain an array of comamnds\n*/\nfunction impedanceSetter(channelNumber, pInputApplied, nInputApplied) {\n  var cmdNInputApplied, cmdPInputApplied;\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isNumber(channelNumber)) reject(Error(\"channelNumber must be of type 'number' \"));\n    if (!isBoolean(pInputApplied)) reject(Error(\"pInputApplied must be of type 'boolean' \"));\n    if (!isBoolean(nInputApplied)) reject(Error(\"nInputApplied must be of type 'boolean' \"));\n\n    // Set pInputApplied\n    cmdPInputApplied = pInputApplied ? obciChannelImpedanceTestSignalApplied : obciChannelImpedanceTestSignalAppliedNot;\n\n    // Set nInputApplied\n    cmdNInputApplied = nInputApplied ? obciChannelImpedanceTestSignalApplied : obciChannelImpedanceTestSignalAppliedNot;\n\n    // Set Channel Number\n    commandChannelForCmd(channelNumber).then(command => {\n      var outputArray = [obciChannelImpedanceSet, command, cmdPInputApplied, cmdNInputApplied, obciChannelImpedanceLatch];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\n/**\n * @description To build the array of commands to send to the board to set the sample rate\n * @param boardType {String} - The type of board, either cyton or ganglion. Default is Cyton\n * @param sampleRate {Number} - The sample rate you want to set to. Please see docs for possible sample rates.\n * @returns {Promise} - fulfilled will contain an array of commands\n */\nfunction sampleRateSetter(boardType, sampleRate) {\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isString(boardType)) return reject(Error(\"board type must be of type 'string' \"));\n\n    if (!isNumber(sampleRate)) return reject(Error(\"sampleRate must be of type 'number' \"));\n\n    sampleRate = Math.floor(sampleRate);\n\n    let func;\n    if (boardType === obciBoardCyton || boardType === obciBoardDaisy) {\n      func = commandSampleRateForCmdCyton;\n    } else if (boardType === obciBoardGanglion) {\n      func = commandSampleRateForCmdGanglion;\n    } else {\n      return reject(Error(`boardType must be either ${obciBoardCyton} or ${obciBoardGanglion}`));\n    }\n\n    // Set Channel Number\n    func(sampleRate).then(command => {\n      var outputArray = [obciSampleRateSet, command];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\n/**\n * @description To build the array of commands to send to the board t\n * @param boardMode {String} - The type of board mode:\n *  `default`: Board will use Accel\n *  `\n * @returns {Promise} - fulfilled will contain an array of commands\n */\nfunction boardModeSetter(boardMode) {\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isString(boardMode)) return reject(Error(\"board mode must be of type 'string' \"));\n    // Set Channel Number\n    commandBoardModeForMode(boardMode).then(command => {\n      var outputArray = [obciBoardModeSet, command];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\nfunction isNumber(input) {\n  return typeof input === 'number';\n}\nfunction isBoolean(input) {\n  return typeof input === 'boolean';\n}\nfunction isString(input) {\n  return typeof input === 'string';\n}\nfunction isUndefined(input) {\n  return typeof input === 'undefined';\n}\nfunction isNull(input) {\n  return input === null;\n}\n\nfunction commandForADCString(adcString) {\n  return new Promise(function (resolve, reject) {\n    switch (adcString) {\n      case obciStringADCNormal:\n        resolve(obciChannelCmdADCNormal);\n        break;\n      case obciStringADCShorted:\n        resolve(obciChannelCmdADCShorted);\n        break;\n      case obciStringADCBiasMethod:\n        resolve(obciChannelCmdADCBiasMethod);\n        break;\n      case obciStringADCMvdd:\n        resolve(obciChannelCmdADCMVDD);\n        break;\n      case obciStringADCTemp:\n        resolve(obciChannelCmdADCTemp);\n        break;\n      case obciStringADCTestSig:\n        resolve(obciChannelCmdADCTestSig);\n        break;\n      case obciStringADCBiasDrp:\n        resolve(obciChannelCmdADCBiasDRP);\n        break;\n      case obciStringADCBiasDrn:\n        resolve(obciChannelCmdADCBiasDRN);\n        break;\n      default:\n        reject(Error('Invalid ADC string'));\n        break;\n    }\n  });\n}\n\n/**\n * Returns the input type for the given command\n * @param cmd {Number} The command\n * @returns {String}\n */\nfunction inputTypeForCommand(cmd) {\n  switch (String(cmd)) {\n    case obciChannelCmdADCNormal:\n      return obciStringADCNormal;\n    case obciChannelCmdADCShorted:\n      return obciStringADCShorted;\n    case obciChannelCmdADCBiasMethod:\n      return obciStringADCBiasMethod;\n    case obciChannelCmdADCMVDD:\n      return obciStringADCMvdd;\n    case obciChannelCmdADCTemp:\n      return obciStringADCTemp;\n    case obciChannelCmdADCTestSig:\n      return obciStringADCTestSig;\n    case obciChannelCmdADCBiasDRP:\n      return obciStringADCBiasDrp;\n    case obciChannelCmdADCBiasDRN:\n      return obciStringADCBiasDrn;\n    default:\n      throw new Error('Invalid input type, must be less than 8');\n  }\n}\n\nfunction commandForGain(gainSetting) {\n  return new Promise(function (resolve, reject) {\n    switch (gainSetting) {\n      case 1:\n        resolve(obciChannelCmdGain1);\n        break;\n      case 2:\n        resolve(obciChannelCmdGain2);\n        break;\n      case 4:\n        resolve(obciChannelCmdGain4);\n        break;\n      case 6:\n        resolve(obciChannelCmdGain6);\n        break;\n      case 8:\n        resolve(obciChannelCmdGain8);\n        break;\n      case 12:\n        resolve(obciChannelCmdGain12);\n        break;\n      case 24:\n        resolve(obciChannelCmdGain24);\n        break;\n      default:\n        reject(Error('Invalid gain setting of ' + gainSetting + ' gain must be (1,2,4,6,8,12,24)'));\n        break;\n    }\n  });\n}\n\n/**\n * Get the gain\n * @param cmd {Number}\n * @returns {Number}\n */\nfunction gainForCommand(cmd) {\n  switch (String(cmd)) {\n    case obciChannelCmdGain1:\n      return 1;\n    case obciChannelCmdGain2:\n      return 2;\n    case obciChannelCmdGain4:\n      return 4;\n    case obciChannelCmdGain6:\n      return 6;\n    case obciChannelCmdGain8:\n      return 8;\n    case obciChannelCmdGain12:\n      return 12;\n    case obciChannelCmdGain24:\n      return 24;\n    default:\n      throw new Error(`Invalid gain setting of ${cmd} gain must be (0,1,2,3,4,5,6)`);\n  }\n}\n\nfunction commandChannelForCmd(channelNumber) {\n  return new Promise(function (resolve, reject) {\n    switch (channelNumber) {\n      case 1:\n        resolve(obciChannelCmdChannel1);\n        break;\n      case 2:\n        resolve(obciChannelCmdChannel2);\n        break;\n      case 3:\n        resolve(obciChannelCmdChannel3);\n        break;\n      case 4:\n        resolve(obciChannelCmdChannel4);\n        break;\n      case 5:\n        resolve(obciChannelCmdChannel5);\n        break;\n      case 6:\n        resolve(obciChannelCmdChannel6);\n        break;\n      case 7:\n        resolve(obciChannelCmdChannel7);\n        break;\n      case 8:\n        resolve(obciChannelCmdChannel8);\n        break;\n      case 9:\n        resolve(obciChannelCmdChannel9);\n        break;\n      case 10:\n        resolve(obciChannelCmdChannel10);\n        break;\n      case 11:\n        resolve(obciChannelCmdChannel11);\n        break;\n      case 12:\n        resolve(obciChannelCmdChannel12);\n        break;\n      case 13:\n        resolve(obciChannelCmdChannel13);\n        break;\n      case 14:\n        resolve(obciChannelCmdChannel14);\n        break;\n      case 15:\n        resolve(obciChannelCmdChannel15);\n        break;\n      case 16:\n        resolve(obciChannelCmdChannel16);\n        break;\n      default:\n        reject(Error('Invalid channel number'));\n        break;\n    }\n  });\n}\n\n/**\n * @typedef {Object} ChannelSettingsObject - See page 50 of the ads1299.pdf\n * @property {Number} channelNumber - The channel number of this object\n * @property {Boolean} powerDown - Power-down: - This boolean determines the channel power mode for the\n *                      corresponding channel. `false` for normal operation, channel is on, and `true` for channel\n *                      power-down, channel is off. (Default is `false`)\n * @property {Number} gain - PGA gain: This number determines the PGA gain setting. Can be either 1, 2, 4, 6, 8, 12, 24\n *                      (Default is 24)\n * @property {String} inputType - Channel input: This string is used to determine the channel input selection.\n *                      Can be:\n *                        'normal' - Normal electrode input (Default)\n *                        'shorted' - Input shorted (for offset or noise measurements)\n *                        'biasMethod' - Used in conjunction with BIAS_MEAS bit for BIAS measurements.\n *                        'mvdd' - MVDD for supply measurement\n *                        'temp' - Temperature sensor\n *                        'testsig' - Test signal\n *                        'biasDrp' - BIAS_DRP (positive electrode is the driver)\n *                        'biasDrn' - BIAS_DRN (negative electrode is the driver)\n * @property {Boolean} bias - BIAS: Is the channel included in the bias? If `true` or yes, this channel has both P\n *                      and N channels connected to the bias. (Default is `true`)\n * @property {Boolean} srb2 - SRB2 connection: This boolean determines the SRB2 connection for the corresponding\n *                      channel. `false` for open, not connected to channel, and `true` for closed, connected to the\n *                      channel. (Default is `true`)\n * @property {Boolean} srb1 - Stimulus, reference, and bias 1: This boolean connects the SRB2 to all 4, 6, or 8\n *                      channels inverting inputs. `false` when switches open, disconnected, and `true` when switches\n *                      closed, or connected. (Default is `false`)\n */\n\n/**\n * Get an object of default board settings.\n * @param channelNumber\n * @returns {ChannelSettingsObject}\n */\nfunction channelSettingsObjectDefault(channelNumber) {\n  return {\n    channelNumber: channelNumber,\n    powerDown: false,\n    gain: 24,\n    inputType: obciStringADCNormal,\n    bias: true,\n    srb2: true,\n    srb1: false\n  };\n}\n\n/**\n * @description RawDataToSample default object creation\n * @param numChannels {Number} - The number of channels\n * @returns {RawDataToSample} - A new object\n */\nfunction rawDataToSampleObjectDefault(numChannels) {\n  if (numChannels === undefined) numChannels = obciNumberOfChannelsDefault;\n  return {\n    accelArray: [0, 0, 0],\n    channelSettings: constantsModule.channelSettingsArrayInit(numChannels),\n    decompressedSamples: decompressedSamplesInit(numChannels),\n    lastSampleNumber: 0,\n    rawDataPacket: __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"].alloc(33),\n    rawDataPackets: [],\n    scale: true,\n    sendCounts: false,\n    timeOffset: 0,\n    verbose: false\n  };\n}\n\nfunction decompressedSamplesInit(numChannels) {\n  let output = [];\n  for (let i = 0; i < 3; i++) {\n    output.push(new Array(numChannels));\n  }\n  return output;\n}\n\n/**\n * Get's the command for sample rate Cyton\n * @param sampleRate {Number} - The desired sample rate\n * @return {Promise}\n */\nfunction commandSampleRateForCmdCyton(sampleRate) {\n  return new Promise(function (resolve, reject) {\n    switch (sampleRate) {\n      case obciSampleRate16000:\n        resolve(obciSampleRateCmdCyton16000);\n        break;\n      case obciSampleRate8000:\n        resolve(obciSampleRateCmdCyton8000);\n        break;\n      case obciSampleRate4000:\n        resolve(obciSampleRateCmdCyton4000);\n        break;\n      case obciSampleRate2000:\n        resolve(obciSampleRateCmdCyton2000);\n        break;\n      case obciSampleRate1000:\n        resolve(obciSampleRateCmdCyton1000);\n        break;\n      case obciSampleRate500:\n        resolve(obciSampleRateCmdCyton500);\n        break;\n      case obciSampleRate250:\n        resolve(obciSampleRateCmdCyton250);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\n * Get's the command for sample rate Cyton\n * @param sampleRate {Number} - The desired sample rate\n * @return {Promise}\n */\nfunction commandSampleRateForCmdGanglion(sampleRate) {\n  return new Promise(function (resolve, reject) {\n    switch (sampleRate) {\n      case obciSampleRate25600:\n        resolve(obciSampleRateCmdGang25600);\n        break;\n      case obciSampleRate12800:\n        resolve(obciSampleRateCmdGang12800);\n        break;\n      case obciSampleRate6400:\n        resolve(obciSampleRateCmdGang6400);\n        break;\n      case obciSampleRate3200:\n        resolve(obciSampleRateCmdGang3200);\n        break;\n      case obciSampleRate1600:\n        resolve(obciSampleRateCmdGang1600);\n        break;\n      case obciSampleRate800:\n        resolve(obciSampleRateCmdGang800);\n        break;\n      case obciSampleRate400:\n        resolve(obciSampleRateCmdGang400);\n        break;\n      case obciSampleRate200:\n        resolve(obciSampleRateCmdGang200);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\n * Get's the command for sample rate Cyton\n * @param boardMode {String} - The desired sample rate\n * @return {Promise}\n */\nfunction commandBoardModeForMode(boardMode) {\n  return new Promise(function (resolve, reject) {\n    switch (boardMode) {\n      case obciBoardModeDefault:\n        resolve(obciBoardModeCmdDefault);\n        break;\n      case obciBoardModeDebug:\n        resolve(obciBoardModeCmdDebug);\n        break;\n      case obciBoardModeAnalog:\n        resolve(obciBoardModeCmdAnalog);\n        break;\n      case obciBoardModeDigital:\n        resolve(obciBoardModeCmdDigital);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\n * @description Get a list of local names from an array of peripherals\n */\nfunction getPeripheralLocalNames(pArray) {\n  return new Promise((resolve, reject) => {\n    var list = [];\n    pArray.forEach(perif => {\n      list.push(perif.advertisement.localName);\n    });\n    if (list.length > 0) {\n      return resolve(list);\n    } else {\n      return reject(Error(`No peripherals discovered with prefix equal to ${obciGanglionPrefix}`));\n    }\n  });\n}\n\n/**\n * @description Get a peripheral with a local name\n * @param `pArray` {Array} - Array of peripherals\n * @param `localName` {String} - The local name of the BLE device.\n */\nfunction getPeripheralWithLocalName(pArray, localName) {\n  return new Promise((resolve, reject) => {\n    if (typeof pArray !== 'object') return reject(Error(`pArray must be of type Object`));\n    pArray.forEach(perif => {\n      if (perif.advertisement.hasOwnProperty('localName')) {\n        if (perif.advertisement.localName === localName) {\n          return resolve(perif);\n        }\n      }\n    });\n    return reject(Error(`No peripheral found with localName: ${localName}`));\n  });\n}\n\n/**\n * @description This function is used to extract the major version from a github\n *  version string.\n * @returns {Number} The major version number\n */\nfunction getVersionNumber(versionStr) {\n  return Number(versionStr[1]);\n}\n\n/**\n * @description Very safely checks to see if the noble peripheral is a\n *  ganglion by way of checking the local name property.\n */\nfunction isPeripheralGanglion(peripheral) {\n  if (peripheral) {\n    if (peripheral.hasOwnProperty('advertisement')) {\n      if (peripheral.advertisement !== null && peripheral.advertisement.hasOwnProperty('localName')) {\n        if (peripheral.advertisement.localName !== undefined && peripheral.advertisement.localName !== null) {\n          if (peripheral.advertisement.localName.indexOf(obciGanglionPrefix) > -1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (constantsModule);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants.js\n// module id = 5\n// module chunks = 0 1 3\n\n//# sourceURL=webpack:///./src/constants.js?");

/***/ })
/******/ ])["default"];
});