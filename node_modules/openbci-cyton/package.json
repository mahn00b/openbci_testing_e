{
  "_from": "openbci-cyton",
  "_id": "openbci-cyton@1.1.2",
  "_inBundle": false,
  "_integrity": "sha1-mFtuPjBYJkrghnMI7G0GRBuzuvg=",
  "_location": "/openbci-cyton",
  "_phantomChildren": {
    "buffer": "5.1.0",
    "buffer-equal": "1.0.0",
    "clone": "2.1.1",
    "complex.js": "2.0.4",
    "decimal.js": "9.0.1",
    "escape-latex": "1.0.0",
    "fraction.js": "4.0.4",
    "gaussian": "1.1.0",
    "javascript-natural-sort": "0.7.1",
    "performance-now": "2.1.0",
    "seed-random": "2.2.0",
    "streamsearch": "0.1.2",
    "tiny-emitter": "2.0.2"
  },
  "_requested": {
    "escapedName": "openbci-cyton",
    "fetchSpec": "latest",
    "name": "openbci-cyton",
    "raw": "openbci-cyton",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/",
    "/openbci"
  ],
  "_resolved": "https://registry.npmjs.org/openbci-cyton/-/openbci-cyton-1.1.2.tgz",
  "_shasum": "985b6e3e3058264ae0867308ec6d06441bb3baf8",
  "_shrinkwrap": null,
  "_spec": "openbci-cyton",
  "_where": "C:\\Users\\Mahmoud\\Documents\\Projects\\openbci_testing_ev",
  "author": {
    "email": "aj@pushtheworld.us",
    "name": "AJ Keller",
    "url": "www.openbci.com"
  },
  "bugs": {
    "url": "https://github.com/openbci/openbci_nodejs_cyton/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "buffer-equal": "^1.0.0",
    "lodash": "^4.17.4",
    "mathjs": "^4.0.1",
    "openbci-utilities": "^0.3.5",
    "performance-now": "^2.1.0",
    "safe-buffer": "^5.1.1",
    "serialport": "^6.1.1",
    "sntp": "^2.0.2"
  },
  "deprecated": false,
  "description": "The official Node.js SDK for the OpenBCI Cyton with Dongle.",
  "devDependencies": {
    "bluebird": "3.5.0",
    "chai": "^4.1.0",
    "chai-as-promised": "^7.1.1",
    "codecov": "^2.1.0",
    "dirty-chai": "^2.0.1",
    "eslint-config-semistandard": "^11.0.0",
    "eslint-config-standard": "^10.2.1",
    "eslint-plugin-promise": "^3.5.0",
    "eslint-plugin-react": "^7.3.0",
    "eslint-plugin-standard": "^3.0.1",
    "istanbul": "^0.4.4",
    "mocha": "^3.4.2",
    "sandboxed-module": "^2.0.3",
    "semistandard": "^11.0.0",
    "sinon": "^1.17.7",
    "sinon-as-promised": "^4.0.3",
    "sinon-chai": "^2.11.0",
    "snazzy": "^7.0.0"
  },
  "directories": {
    "test": "test"
  },
  "engines": {
    "node": ">=6.0.0"
  },
  "homepage": "https://github.com/openbci/openbci_nodejs_cyton#readme",
  "keywords": [
    "openbci",
    "openbci-node"
  ],
  "license": "MIT",
  "main": "openBCICyton.js",
  "name": "openbci-cyton",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/OpenBCI/OpenBCI_NodeJS_Cyton.svg?branch=master)](https://travis-ci.org/OpenBCI/OpenBCI_NodeJS_Cyton)\n[![codecov](https://codecov.io/gh/OpenBCI/OpenBCI_NodeJS_Cyton/branch/master/graph/badge.svg)](https://codecov.io/gh/OpenBCI/OpenBCI_NodeJS_Cyton)\n[![Dependency Status](https://david-dm.org/OpenBCI/OpenBCI_NodeJS_Cyton.svg)](https://david-dm.org/OpenBCI/OpenBCI_NodeJS_Cyton)\n[![npm](https://img.shields.io/npm/dm/openbci.svg?maxAge=2592000)](http://npmjs.com/package/openbci-cyton)\n[![js-semistandard-style](https://img.shields.io/badge/code%20style-semistandard-brightgreen.svg?style=flat-square)](https://github.com/Flet/semistandard)\n\n# OpenBCI Node.js Cyton SDK\n\nA Node.js module for OpenBCI Cyton ~ written with love by [Push The World!](http://www.pushtheworldllc.com)\n\nWe are proud to support all functionality of the Cyton (8 and 16 Channel boards). For the Ganglion (4 channel) please visit [OpenBCI_NodeJS_Ganglion](https://github.com/OpenBCI/OpenBCI_NodeJS_Ganglion). Push The World is actively developing and maintaining this module.\n\nThe purpose of this module is to **get connected** and **start streaming** as fast as possible.\n\nPython researcher or developer? Check out how easy it is to [get access to the entire API in the Python example](examples/python)!\n\n### Table of Contents:\n---\n\n1. [Installation](#install)\n2. [TL;DR](#tldr)\n3. [Cyton (32bit Board)](#cyton)\n  1. [About](#about)\n  2. [General Overview](#general-overview)\n  3. [SDK Reference Guide](#sdk-reference-guide)\n    * [Constructor](#constructor)\n    * [Methods](#method)\n    * [Events](#event)\n    * [Constants](#constants)\n6. [Interfacing With Other Tools](#interfacing-with-other-tools)\n7. [Developing](#developing)\n8. [Testing](#developing-testing)\n9. [Contribute](#contribute)\n10. [License](#license)\n11. [Roadmap](#roadmap)\n\n### <a name=\"install\"></a> Installation:\n```\nnpm install openbci-cyton\n```\n#### serialport dependency\nIf you encounter this error when trying to run:\n```\nError: The module '/path/to/your/project/node_modules/serialport/build/Release/serialport.node'\nwas compiled against a different Node.js version using\nNODE_MODULE_VERSION 48. This version of Node.js requires\nNODE_MODULE_VERSION 51. Please try re-compiling or re-installing\nthe module (for instance, using `npm rebuild` or`npm install`).\n```\n...the issue can be resolved by running:\n```\nnpm rebuild --build-from-source\n```\n### <a name=\"tldr\"></a> TL;DR:\nGet connected and [start streaming right now with the example code](examples/getStreaming/getStreaming.js).\n\n#### Cyton (8 and 16 channel boards)\n```ecmascript 6\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName) // Port name is a serial port name, see `.listPorts()`\n  .then(() => {\n    ourBoard.streamStart();\n    ourBoard.on('sample',(sample) => {\n      /** Work with sample */\n      for (let i = 0; i < ourBoard.numberOfChannels(); i++) {\n        console.log(\"Channel \" + (i + 1) + \": \" + sample.channelData[i].toFixed(8) + \" Volts.\");\n        // prints to the console\n        //  \"Channel 1: 0.00001987 Volts.\"\n        //  \"Channel 2: 0.00002255 Volts.\"\n        //  ...\n        //  \"Channel 8: -0.00001875 Volts.\"\n      }\n    });\n});\n```\n\n\n# <a name=\"cyton\"></a> Cyton\n\n## <a name=\"about\"></a> About:\nWant to know if the module really works? Check out some projects and organizations using it:\n\n* [_OpenEXP_](https://github.com/openexp/OpenEXP): an open-source desktop app for running experiments and collecting behavioral and physiological data.\n* [_Thinker_](http://www.pushtheworldllc.com/): a project building the world's first brainwave-word database.\n* [_NeuroJS_](https://github.com/NeuroJS): a community dedicated to Neuroscience research using JavaScript, they have several great examples.\n\nStill not satisfied it works?? Check out this [detailed report](http://s132342840.onlinehome.us/pushtheworld/files/voltageVerificationTestPlanAndResults.pdf) that scientifically validates the output voltages of this module.\n\nHow are you still doubting and not using this already? Fine, go look at some of the [800 **_automatic_** tests](https://codecov.io/gh/OpenBCI/OpenBCI_NodeJS) written for it!\n\n## <a name=\"general-overview\"></a> General Overview:\n\nPython researcher or developer? Check out how easy it is to [get access to the entire API in the Python example](examples/python)!\n\nInitialization\n--------------\n\nInitializing the board:\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\n```\nGo [checkout out the get streaming example](examples/getStreaming/getStreaming.js)!\n\nFor initializing with options, such as verbose print outs:\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton({\n  verbose: true\n});\n```\n\nOr if you don't have a board and want to use synthetic data:\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton({\n  simulate: true\n});\n```\n\nHave a daisy?:\n```js\nvar Cyton = require('openbci-cyton');\nvar ourBoard = new Cyton({\n    boardType: `daisy`,\n    hardSet: true\n});\n```\nGo [checkout out the get streaming with daisy example](examples/getStreamingDaisy/getStreamingDaisy.js)!\n\nAnother useful way to start the simulator:\n```js\nconst Cyton = require('openbci-cyton');\nconst k = require('openbci-utilities').Constants;\nconst ourBoard = new Cyton();\nourBoard.connect(k.OBCISimulatorPortName) // This will set `simulate` to true\n    .then((boardSerial) => {\n        ourBoard.on('ready',() => {\n            /** Start streaming, reading registers, what ever your heart desires  */\n        });\n    }).catch((err) => {\n        /** Handle connection errors */\n    });\n```\n\nYou can also start the simulator by sending [`.connect(portName)`](#method-connect) with `portName` equal to [`'OpenBCISimulator'`](#constants-obcisimulatorportname).\n\nor if you are using ES6:\n```js\nimport Cyton from 'openbci-cyton';\nimport { Constants } from 'openbci-utilities';\nconst ourBoard = new Cyton();\nourBoard.connect(Constants.OBCISimulatorPortName);\n```\n\nTo debug, it's amazing, do:\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton({\n    debug: true\n});\n```\nGo [checkout out the debug example](examples/debug/debug.js)!\n\n'ready' event\n------------\n\nYou MUST wait for the 'ready' event to be emitted before streaming/talking with the board. The ready happens asynchronously\nso installing the 'sample' listener and writing before the ready event might result in... nothing at all.\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(function(boardSerial) {\n   /** Start streaming, reading registers, what ever your heart desires  */\n}).catch(function(err) {\n    /** Handle connection errors */\n});            \n```\n\nSample properties:\n------------------\n* `startByte` (`Number` should be `0xA0`)\n* `sampleNumber` (a `Number` between 0-255)\n* `channelData` (channel data indexed at 0 filled with floating point `Numbers` in Volts) if `sendCounts` is false\n* `channelDataCounts` (channel data indexed at 0 filled with floating point `Numbers` in Volts) if `sendCounts` is true\n* `accelData` (`Array` with X, Y, Z accelerometer values when new data available) if `sendCounts` is false\n* `accelDataCounts` (`Array` with X, Y, Z accelerometer values when new data available) Only present if `sendCounts` is true\n* `auxData` (`Buffer` filled with either 2 bytes (if time synced) or 6 bytes (not time synced))\n* `stopByte` (`Number` should be `0xCx` where x is 0-15 in hex)\n* `boardTime` (`Number` the raw board time)\n* `timestamp` (`Number` the `boardTime` plus the NTP calculated offset)\n\nThe power of this module is in using the sample emitter, to be provided with samples to do with as you wish.\n\nTo get a ['sample'](#event-sample) event, you need to:\n-------------------------------------\n1. Call [`.connect(serialPortName)`](#method-connect)\n2. Install the ['ready'](#event-ready) event emitter on resolved promise\n3. In callback for ['ready'](#event-ready) emitter, call [`streamStart()`](#method-stream-start)\n4. Install the ['sample'](#event-sample) event emitter\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(function() {\n  ourBoard.streamStart();\n  ourBoard.on('sample',function(sample) {\n    /** Work with sample */\n  });\n}).catch(function(err) {\n    /** Handle connection errors */\n});            \n```\nClose the connection with [`.streamStop()`](#method-stream-stop) and disconnect with [`.disconnect()`](#method-disconnect)\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.streamStop().then(ourBoard.disconnect());\n```\n\nTime Syncing\n------------\nYou must be using OpenBCI firmware version 2 in order to do time syncing. After you [`.connect()`](#method-connect) and send a [`.softReset()`](#method-soft-reset), you can call [`.usingVersionTwoFirmware()`](#method-using-version-two-firmware) to get a boolean response as to if you are using `v1` or `v2`.\n\nNow using firmware `v2`, the fun begins! We synchronize the Board's clock with the module's time. In firmware `v2` we leverage samples with time stamps and _ACKs_ from the Dongle to form a time synchronization strategy. Time syncing has been verified to +/- 4ms and a test report is on the way. We are still working on the synchronize of this module and an NTP server, this is an open call for any NTP experts out there! With a global NTP server you could use several different devices and all sync to the same time server. That way you can really do some serious cloud computing!\n\nKeep your resync interval above 50ms. While it's important to resync every couple minutes due to drifting of clocks, please do not try to sync without getting the last sync event! We can only support one sync operation at a time!\n\nUsing local computer time:\n```js\nconst Cyton = require('openbci-cyton');\nconst k = require('openbci-utilities').Constants;\nconst ourBoard = new Cyton({\n  verbose:true\n});\n\nconst resyncPeriodMin = 5; // re sync every five minutes\nconst secondsInMinute = 60;\nlet sampleRate = k.OBCISampleRate250; // Default to 250, ALWAYS verify with a call to `.sampleRate()` after 'ready' event!\nlet timeSyncPossible = false;\n\n// Call to connect\nourBoard.connect(portName).then(() => {\n  // Get the sample rate after 'ready'\n  sampleRate = ourBoard.sampleRate();\n  // Find out if you can even time sync, you must be using v2 and this is only accurate after a `.softReset()` call which is called internally on `.connect()`. We parse the `.softReset()` response for the presence of firmware version 2 properties.\n  timeSyncPossible = ourBoard.usingVersionTwoFirmware();\n    \n  ourBoard.streamStart()\n    .then(() => {\n      /** Start streaming command sent to board. */\n    }).catch(err => {\n      console.log(`stream start: ${err}`);\n    });\n\n  // PTW recommends sample driven  \n  ourBoard.on('sample',sample => {\n    // Resynchronize every every 5 minutes\n    if (sample._count % (sampleRate * resyncPeriodMin * secondsInMinute) === 0) {\n      ourBoard.syncClocksFull()\n        .then(syncObj => {\n          // Sync was successful\n          if (syncObj.valid) {\n            // Log the object to check it out!\n            console.log(`syncObj`,syncObj);\n    \n            // Sync was not successful\n            } else {\n              // Retry it\n              console.log(`Was not able to sync, please retry?`);\n            }\n        });\n    }\n    \n    if (sample.timeStamp) { // true after the first sync\n      console.log(`NTP Time Stamp ${sample.timeStamp}`);\n    }\n    \n  });\n})\n.catch(err => {\n  console.log(`connect: ${err}`);\n});\n```\n\nAuto-finding boards\n-------------------\nYou must have the OpenBCI board connected to the PC before trying to automatically find it.\n\nIf a port is not automatically found, then call [`.listPorts()`](#method-list-ports) to get a list of all serial ports this would be a good place to present a drop down picker list to the user, so they may manually select the serial port name.\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.autoFindOpenBCIBoard().then(portName => {\n    if(portName) {\n        /**\n        * Connect to the board with portName\n        * i.e. ourBoard.connect(portName).....\n        */\n    } else {\n        /**Unable to auto find OpenBCI board*/\n    }\n});\n```\n\nNote: [`.autoFindOpenBCIBoard()`](#method-auto-find-open-bci-board) will return the name of the Simulator if you instantiate with option `simulate: true`.\n\nAuto Test - (Using impedance to determine signal quality)\n---------------------------------------------------------\nMeasuring impedance is a vital tool in ensuring great data is collected.\n\n**_IMPORTANT!_** Measuring impedance takes time, so *only test what you must*\n\nYour OpenBCI board will have electrodes hooked up to either a P input, N input or in some cases both inputs.\n\nTo test specific inputs of channels:\n\n1. Connect to board.\n2. Start streaming.\n3. Install the ['impedanceArray'](#event-impedance-array) event\n4. Call [`.impedanceTestChannels()`](#method-impedance-test-channels) with your configuration array\n\nA configuration array looks like, for an 8 channel board, `['-','N','n','p','P','-','b','b']`\n\nWhere there are the same number of elements as channels and each element can be either:\n\n* `p` or `P` (only test P input)\n* `n` or `N` (only test N input)\n* `b` or `B` (test both inputs) (takes 66% longer to run then previous two `p` or `n`)\n* `-` (ignore channel)\n\nWithout further ado, here is an example:\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.streamStart();\n    ourBoard.once('impedanceArray', impedanceArray => {\n        /** Work with impedance Array */\n    });\n    ourBoard.impedanceTestChannels(['n','N','n','p','P','p','b','B']).catch(err => console.log(err));\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\n\nBut wait! What is this `impedanceArray`? An Array of Objects, for each object:\n```\n[{\n    channel: 1,\n    P: {\n        raw: -1,\n        text: 'init'\n    },\n    N: {\n        raw: -1,\n        text: 'init'\n    }\n},\n{\n    // Continues for each channel up to the amount of channels on board (8 or 16)\n},...];\n```\n\nWhere:\n\n* *channel* is the channel number (`impedanceArray[0]` is channel 1, `impedanceArray[6]` is channel 7)\n* *P* is the P input data (Note: P is capitalized)\n  * *raw* is an impedance value resulting from the Goertzel algorithm.\n  * *text* is a text interpretation of the `average`\n    * **Good** impedance is < 5k Ohms\n    * **Ok** impedance is 5 to 10k Ohms\n    * **Bad** impedance is > 10k Ohms\n    * **None** impedance is > 1M Ohms\n* *N* is the N input data (Note: N is capitalized) (see above for what N object consists of)\n\nTo run an impedance test on all inputs, one channel at a time:\n\n1. Connect to board\n2. Start streaming\n3. Install the ['impedanceArray'](#event-impedance-array)\n4. Call [`.impedanceTestAllChannels()`](#method-impedance-test-all-channels)\n\n**Note: Takes up to 5 seconds to start measuring impedances. There is an unknown number of samples taken. Not always 60!**\n\nFor example:\n\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.streamStart();\n    ourBoard.on('impedanceArray', impedanceArray => {\n        /** Work with impedance */\n    });\n    ourBoard.impedanceTestAllChannels();\n}\n```\n\nSee Reference Guide for a complete list of impedance tests.\n\n## <a name=\"sdk-reference-guide\"></a> SDK Reference Guide:\n---------------\n### <a name=\"constructor\"></a> Constructor:\n\n#### <a name=\"init\"></a> Cyton (options)\n\nCreate new instance of an Cyton board.\n\n**_options (optional)_**\n\nBoard optional configurations.\n\n* `baudRate` {Number} - Baud Rate, defaults to 115200. Manipulating this is allowed if firmware on board has been previously configured.\n* `boardType` {String} - Specifies type of OpenBCI board (3 possible boards)\n  * `default` - 8 Channel OpenBCI board (Default)\n  * `daisy` - 8 Channel board with Daisy Module - 16 Channels\n* `hardSet` {Boolean} - Recommended if using `daisy` board! For some reason, the `daisy` is sometimes not picked up by the module so you can set `hardSet` to true which will ensure the daisy is picked up. (Default `false`)\n* `simulate` {Boolean} - Full functionality, just mock data. Must attach Daisy module by setting `simulatorDaisyModuleAttached` to `true` in order to get 16 channels. (Default `false`)\n* `simulatorBoardFailure` {Boolean} - Simulates board communications failure. This occurs when the RFduino on the board is not polling the RFduino on the dongle. (Default `false`)\n* `simulatorDaisyModuleAttached` {Boolean} - Simulates a daisy module being attached to the OpenBCI board. This is useful if you want to test how your application reacts to a user requesting 16 channels but there is no daisy module actually attached, or vice versa, where there is a daisy module attached and the user only wants to use 8 channels. (Default `false`)\n* `simulatorFirmwareVersion` {String} - Allows the simulator to use firmware version 2 features. (2 Possible Options)\n  * `v1` - Firmware Version 1 (Default)\n  * `v2` - Firmware Version 2\n* `simulatorFragmentation` {String} - Specifies how to break packets to simulate fragmentation, which occurs commonly in real devices.  It is recommended to test code with this enabled.  (4 Possible Options)\n  * `none` - do not fragment packets; output complete chunks immediately when produced (Default)\n  * `random` - output random small chunks of data interspersed with full buffers\n  * `fullBuffers` - allow buffers to fill up until latency timer has expired\n  * `oneByOne` - output each byte separately\n* `simulatorLatencyTime` {Number} - The time in milliseconds to wait before sending partially full buffers of data, if `simulatorFragmentation` is specified.  (Default `16`)\n* `simulatorBufferSize` {Number} - The size of a full buffer of data, if `simulatorFragmentation` is specified. (Default `4096`)\n* `simulatorHasAccelerometer` - {Boolean} - Sets simulator to send packets with accelerometer data. (Default `true`)\n* `simulatorInjectAlpha` - {Boolean} - Inject a 10Hz alpha wave in Channels 1 and 2 (Default `true`)\n* `simulatorInjectLineNoise` {String} - Injects line noise on channels. (3 Possible Options)\n  * `60Hz` - 60Hz line noise (Default) [America]\n  * `50Hz` - 50Hz line noise [Europe]\n  * `none` - Do not inject line noise.\n* `simulatorSampleRate` {Number} - The sample rate to use for the simulator. Simulator will set to 125 if `simulatorDaisyModuleAttached` is set `true`. However, setting this option overrides that setting and this sample rate will be used. (Default is `250`)\n* `simulatorSerialPortFailure` {Boolean} - Simulates not being able to open a serial connection. Most likely due to a OpenBCI dongle not being plugged in.\n* `sntpTimeSync` - {Boolean} Syncs the module up with an SNTP time server and uses that as single source of truth instead of local computer time. If you are running experiments on your local computer, keep this `false`. (Default `false`)\n* `sntpTimeSyncHost` - {String} The sntp server to use, can be either sntp or ntp (Defaults `pool.ntp.org`).\n* `sntpTimeSyncPort` - {Number} The port to access the sntp server (Defaults `123`)\n* `verbose` {Boolean} - Print out useful debugging events (Default `false`)\n* `debug` {Boolean} - Print out a raw dump of bytes sent and received (Default `false`)\n\n**Note, we have added support for either all lowercase OR camel case for the options, use whichever style you prefer.**\n\n### <a name=\"methods\"></a> Methods:\n\n#### <a name=\"method-auto-find-open-bci-board\"></a> .autoFindOpenBCIBoard()\n\nAutomatically find an OpenBCI board.\n\n**Note: This will always return an Array of `COM` ports on Windows**\n\n**_Returns_** a promise, fulfilled with a `portName` such as `/dev/tty.*` on Mac/Linux or `OpenBCISimulator` if `this.options.simulate === true`.\n\n#### <a name=\"method-channel-off\"></a> .channelOff(channelNumber)\n\nTurn off a specified channel\n\n**_channelNumber_**\n\nA number (1-16) specifying which channel you want to turn off.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n#### <a name=\"method-channel-on\"></a> .channelOn(channelNumber)\n\nTurn on a specified channel\n\n**_channelNumber_**\n\nA number (1-16) specifying which channel you want to turn on.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n#### <a name=\"method-\"></a> .channelSet(channelNumber,powerDown,gain,inputType,bias,srb2,srb1)\n\nSend a channel setting command to the board.\n\n**_channelNumber_**  \n\nDetermines which channel to set. It's a 'Number' (1-16)\n\n**_powerDown_**\n\nPowers the channel up or down. It's a 'Bool' where `true` turns the channel off and `false` turns the channel on (default)\n\n**_gain_**\n\nSets the gain for the channel. It's a 'Number' that is either (1,2,4,6,8,12,24(default))\n\n**_inputType_**\n\nSelects the ADC channel input source. It's a 'String' that **MUST** be one of the following: \"normal\", \"shorted\", \"biasMethod\" , \"mvdd\" , \"temp\" , \"testsig\", \"biasDrp\", \"biasDrn\".\n\n**_bias_**\n\nSelects if the channel shall include the channel input in bias generation. It's a 'Bool' where `true` includes the channel in bias (default) or `false` it removes it from bias.\n\n**_srb2_**\n\nSelect to connect (`true`) this channel's P input to the SRB2 pin. This closes a switch between P input and SRB2 for the given channel, and allows the P input to also remain connected to the ADC. It's a 'Bool' where `true` connects this input to SRB2 (default) or `false` which disconnect this input from SRB2.\n\n**_srb1_**\n\nSelect to connect (`true`) all channels' N inputs to SRB1. This effects all pins, and disconnects all N inputs from the ADC. It's a 'Bool' where `true` connects all N inputs to SRB1 and `false` disconnects all N inputs from SRB1 (default).\n\n**_Returns_** a promise fulfilled if proper commands sent to the write queue, rejects on bad input or no board.\n\n**Example**\n```js\nourBoard.channelSet(2,false,24,'normal',true,true,false);\n// sends ['x','2','0','6','0','1','1','0','X'] to the command queue\n```\n\n#### <a name=\"method-connect\"></a> .connect(portName)\n\nThe essential precursor method to be called initially to establish a serial connection to the OpenBCI board.\n\n**_portName_**\n\nThe system path of the OpenBCI board serial port to open. For example, `/dev/tty` on Mac/Linux or `COM1` on Windows.\n\n**_Returns_** a promise, fulfilled by a successful serial connection to the board.\n\n#### <a name=\"method-debug-session\"></a> .debugSession()\n\nCalls all [`.printPacketsBad()`](#method-print-packets-bad), [`.printPacketsRead()`](#method-print-packets-read), [`.printBytesIn()`](#method-print-bytes-in)\n\n#### <a name=\"method-disconnect\"></a> .disconnect()\n\nCloses the serial port opened by [`.connect()`](#method-connect).  Waits for stop streaming command to be sent if currently streaming.\n\n**_Returns_** a promise, fulfilled by a successful close of the serial port object, rejected otherwise.\n\n### <a name=\"method-get-info\"></a> .getInfo()\n\nGet the core info object. It's the object that actually drives the parsing of data.\n\n**_Returns_** Object - {{boardType: string, sampleRate: number, firmware: string, numberOfChannels: number, missedPackets: number}}\n\n### <a name=\"method-get-settings-for-channel\"></a> .getSettingsForChannel(channelNumber)\n\nGets the specified channelSettings register data from printRegisterSettings call.\n\n**_channelNumber_**\n\nA number specifying which channel you want to get data on. Only 1-8 at this time.\n\n**Note, at this time this does not work for the daisy board**\n\n**_Returns_** a promise, fulfilled if the command was sent to the board and the `.processBytes()` function is ready to reach for the specified channel.\n\n### <a name=\"method-hard-set-board-type\"></a> .hardSetBoardType(boardType)\n\nUsed to sync the module and board to `boardType`.\n\n**Note: This has the potential to change the way data is parsed** \n \n**_boardType_**\n\nA String indicating the number of channels.\n\n* `default` - Default board: Sample rate is `250Hz` and number of channels is `8`. \n* `daisy` - Daisy board: Sample rate is `125Hz` and number of channels is `16`.\n\n**_Returns_** a promise, fulfilled if both the board and module are the requested `boardType`, rejects otherwise.\n\n### <a name=\"method-impedance-test-all-channels\"></a> .impedanceTestAllChannels()\n\nTo apply test signals to the channels on the OpenBCI board used to test for impedance. This can take a little while to actually run (<8 seconds)!\n\nDon't forget to install the ['impedanceArray'](#event-impedance-array) emitter to receive the impendances!\n\n**Note, you must be connected in order to set the test commands. Also this method can take up to 5 seconds to send all commands!**\n\n**_Returns_** a promise upon completion of test.  \n\n#### <a name=\"method-impedance-test-channels\"></a> .impedanceTestChannels(arrayOfCommands)\n\n**_arrayOfCommands_**\n\nThe array of configurations where there are the same number of elements as channels and each element can be either:\n\n* `p` or `P` (only test P input)\n* `n` or `N` (only test N input)\n* `b` or `B` (test both inputs) (takes 66% longer to run then previous two `p` or `n`)\n* `-` (ignore channel)\n\nDon't forget to install the `impedanceArray` emitter to receive the impendances!\n\n**Note, you must be connected in order to set the test commands. Also this method can take up to 5 seconds to send all commands!**\n\n**_Returns_** a promise upon completion of test.  \n\n#### <a name=\"method-impedance-test-channel\"></a> .impedanceTestChannel(channelNumber)\n\nRun a complete impedance test on a single channel, applying the test signal individually to P & N inputs.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\n**Example**\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(function(boardSerial) {\n    ourBoard.on('ready',function() {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannel(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\nWhere an impedance for this method call would look like:\n```json\n{\n    \"channel\": 1,\n    \"P\": {\n        \"raw\": 2394.45,\n        \"text\": \"good\"\n    },\n    \"N\": {\n        \"raw\": 7694.45,\n        \"text\": \"ok\"\n    }\n}\n```\n\n#### <a name=\"method-impedance-test-channel-input-p\"></a> .impedanceTestChannelInputP(channelNumber)\n\nRun impedance test on a single channel, applying the test signal only to P input.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\n**Example**\n```js\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(() => {\n    ourBoard.on('ready', () => {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannelInputP(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(function(err) {\n    /** Handle connection errors */\n});\n```\nWhere an impedance for this method call would look like:\n```json\n{\n    \"channel\": 1,\n    \"P\": {\n        \"raw\": 2394.45,\n        \"text\": \"good\"\n    },\n    \"N\": {\n        \"raw\": -1,\n        \"text\": \"init\"\n    }\n}\n```\n\n#### <a name=\"method-impedance-test-channel-input-n\"></a> .impedanceTestChannelInputN(channelNumber)\n\nRun impedance test on a single channel, applying the test signal only to N input.\n\n**_channelNumber_**\n\nA Number, specifies which channel you want to test.\n\n**_Returns_** a promise that resolves a single channel impedance object.\n\n**Example**\n```ecmascript 6\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton();\nourBoard.connect(portName).then(() => {\n    ourBoard.on('ready',() => {\n        ourBoard.streamStart();\n        ourBoard.impedanceTestChannelInputN(1)\n            .then(impedanceObject => {\n                /** Do something with impedanceObject! */\n            })\n            .catch(err => console.log(err));\n    });\n}).catch(err => console.log(err));\n\n```\nWhere an impedance for this method call would look like:\n```json\n{\n    \"channel\": 1,\n    \"P\": {\n        \"raw\": -1,\n        \"text\": \"init\"\n    },\n    \"N\": {\n        \"raw\": 7694.45,\n        \"text\": \"ok\"\n    }\n}\n```\n\n#### <a name=\"method-impedance-test-continuous-start\"></a> .impedanceTestContinuousStart()\n\nSends command to turn on impedances for all channels and continuously calculate their impedances.\n\n**_Returns_** a promise, that fulfills when all the commands are sent to the internal write buffer\n\n#### <a name=\"method-impedance-test-continuous-stop\"></a> .impedanceTestContinuousStop()\n\nSends command to turn off impedances for all channels and stop continuously calculate their impedances.\n\n**_Returns_** a promise, that fulfills when all the commands are sent to the internal write buffer\n\n#### <a name=\"method-is-connected\"></a> .isConnected()\n\nChecks if the driver is connected to a board.\n**_Returns_** a boolean, true if connected\n\n#### <a name=\"method-is-streaming\"></a> .isStreaming()\n\nChecks if the board is currently sending samples.\n**_Returns_** a boolean, true if streaming\n\n#### <a name=\"method-list-ports\"></a> .listPorts()\n\nList available ports so the user can choose a device when not automatically found.\n\n**_Returns_** a promise, fulfilled with a list of available serial ports.\n\n#### <a name=\"method-number-of-channels\"></a> .numberOfChannels()\n\nGet the current number of channels available to use. (i.e. 8 or 16).\n\n**Note: This is dependent on if you configured the board correctly on setup options. Specifically as a daisy.**\n\n**_Returns_** a number, the total number of available channels.\n\n### <a name=\"method-override-info-for-board-type\"></a> .overrideInfoForBoardType(boardType)\n\nSet the info property for board type. \n\n**Note: This has the potential to change the way data is parsed** \n \n**_boardType_**\n\nA String indicating the number of channels.\n\n* `default` - Default board: Sample rate is `250Hz` and number of channels is `8`. \n* `daisy` - Daisy board: Sample rate is `125Hz` and number of channels is `16`.\n\n### <a name=\"method-print-bytes-in\"></a> .printBytesIn()\n\nPrints the total number of bytes that were read in this session to the console.\n\n#### <a name=\"method-print-packets-bad\"></a> .printPacketsBad()\n\nPrints the total number of packets that were not able to be read in this session to the console.\n\n#### <a name=\"method-print-packets-read\"></a> .printPacketsRead()\n\nPrints the total number of packets that were read in this session to the console.\n\n#### <a name=\"method-print-register-settings\"></a> .printRegisterSettings()\n\nPrints all register settings for the ADS1299 and the LIS3DH on the OpenBCI board.\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n#### <a name=\"method-radio-baud-rate-set\"></a> .radioBaudRateSet(speed)\n\nUsed to set the OpenBCI Host (Dongle) baud rate. With the RFduino configuration, the Dongle is the Host and the Board is the Device. Only the Device can initiate a communication between the two entities. There exists a detrimental error where if the Host is interrupted by the radio during a Serial write, then all hell breaks loose. So this is an effort to eliminate that problem by increasing the rate at which serial data is sent from the Host to the Serial driver. The rate can either be set to default or fast. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve the new baud rate after closing the current serial port and reopening one.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_speed_**\n\n{String} - The baud rate that to switch to. Can be either `default` (115200) or `fast` (230400).\n\n**_Returns_** {Promise} - Resolves a {Number} that is the new baud rate, rejects on error.\n\n#### <a name=\"method-radio-channel-get\"></a> .radioChannelGet()\n\nUsed to query the OpenBCI system for it's radio channel number. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve an Object. See `returns` below.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolve an object with keys `channelNumber` which is a Number and `err` which contains an error in the condition that there system is experiencing board communications failure.\n\n#### <a name=\"method-radio-channel-set\"></a> .radioChannelSet(channelNumber)\n\nUsed to set the system radio channel number. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_channelNumber_**\n\n{Number} - The channel number you want to set to, 1-25.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n#### <a name=\"method-radio-channel-set-host-override\"></a> .radioChannelSetHostOverride(channelNumber)\n\nUsed to set the ONLY the radio dongle Host channel number. This will fix your radio system if your dongle and board are not on the right channel and bring down your radio system if you take your dongle and board are not on the same channel. Use with caution! The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_channelNumber_**\n\n{Number} - The channel number you want to set to, 1-25.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n#### <a name=\"method-radio-poll-time-get\"></a> .radioPollTimeGet()\n\nUsed to query the OpenBCI system for it's device's poll time. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve the poll time when fulfilled. It's important to note that if the board is not on, this function will always be rejected with a failure message.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolves with the new poll time, rejects with err.\n\n#### <a name=\"method-radio-poll-time-set\"></a> .radioPollTimeSet(pollTime)\n\nUsed to set the OpenBCI poll time. With the RFduino configuration, the Dongle is the Host and the Board is the Device. Only the Device can initiate a communication between the two entities. Therefore this sets the interval at which the Device polls the Host for new information. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware 2+ then this function should resolve.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_pollTime_**\n\n{Number} - The poll time you want to set to, 0-255.\n\n**_Returns_** {Promise} - Resolves with the new channel number, rejects with err.\n\n#### <a name=\"method-radio-system-status-get\"></a> .radioSystemStatusGet()\n\nUsed to ask the Host if it's radio system is up. This is useful to quickly determine if you are in fact ready to start trying to connect and such. The function will reject if not connected to the serial port of the dongle. Further the function should reject if currently streaming. Lastly and more important, if the board is not running the new firmware then this functionality does not exist and thus this method will reject. If the board is using firmware +v2.0.0 and the radios are both on the same channel and powered, then this will resolve true.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} - Resolves true if both radios are powered and on the same channel; false otherwise.\n\n#### <a name=\"method-sample-rate\"></a> .sampleRate()\n\nGet the current sample rate.\n\n**Note: This is dependent on if you configured the board correctly on setup options. Specifically as a daisy.**\n\n**_Returns_** a number, the current sample rate.\n\n#### <a name=\"method-sd-start\"></a> .sdStart(recordingDuration)\n\nStart logging to the SD card. If you are not streaming when you send this command, then you should expect to get a success or failure message followed by and end of transmission `$$$`.\n\n**_recordingDuration_**\n\nThe duration you want to log SD information for. Opens a new SD file to write into. Limited to:\n\n * `14sec` - 14 seconds\n * `5min` - 5 minutes\n * `15min` - 15 minutes\n * `30min` - 30 minutes\n * `1hour` - 1 hour\n * `2hour` - 2 hour\n * `4hour` - 4 hour\n * `12hour` - 12 hour\n * `24hour` - 24 hour\n\n**Note: You must have the proper type of SD card inserted into the board for logging to work.**\n\n**_Returns_** resolves if the command was added to the write queue.\n\n#### <a name=\"method-sd-stop\"></a> .sdStop()\n\nStop logging to the SD card and close any open file. If you are not streaming when you send this command, then you should expect to get a success or failure message followed by and end of transmission `$$$`. The success message contains a lot of useful information about what happened when writing to the SD card.\n\n**_Returns_** resolves if the command was added to the write queue.\n\n#### <a name=\"method-simulator-enable\"></a> .simulatorEnable()\n\nTo enter simulate mode. Must call [`.connect()`](#method-connect) after.\n\n**Note, must be called after the constructor.**\n\n**_Returns_** a promise, fulfilled if able to enter simulate mode, reject if not.\n\n#### <a name=\"method-simulator-disable\"></a> .simulatorDisable()\n\nTo leave simulate mode.\n\n**Note, must be called after the constructor.**\n\n**_Returns_** a promise, fulfilled if able to stop simulate mode, reject if not.\n\n#### <a name=\"method-sntp\"></a> .sntp\n\nExtends the popular SNTP package on [npmjs](https://www.npmjs.com/package/sntp)\n\n#### <a name=\"method-sntp-get-offset\"></a> .sntpGetOffset()\n\nStateful method for querying the current offset only when the last one is too old. (defaults to daily)\n\n**_Returns_** a promise with the time offset\n\n#### <a name=\"method-sntp-start\"></a> .sntpStart()\n\nThis starts the SNTP server and gets it to remain in sync with the SNTP server.\n\n**_Returns_** a promise if the module was able to sync with NTP server.\n\n#### <a name=\"method-sntp-stop\"></a> .sntpStop()\n\nStops the SNTP from updating\n\n#### <a name=\"method-soft-reset\"></a> .softReset()\n\nSends a soft reset command to the board.\n\n**Note, this method must be sent to the board before you can start streaming. This triggers the initial 'ready' event emitter.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue.\n\n#### <a name=\"method-stream-start\"></a> .streamStart()\n\nSends a start streaming command to the board.\n\n**Note, You must have called and fulfilled [`.connect()`](#method-connect) AND observed a `'ready'` emitter before calling this method.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue, rejected if unable.\n\n#### <a name=\"method-stream-stop\"></a> .streamStop()\n\nSends a stop streaming command to the board.\n\n**Note, You must have called and fulfilled [`.connect()`](#method-connect) AND observed a `'ready'` emitter before calling this method.**\n\n**_Returns_** a promise, fulfilled if the command was sent to the write queue, rejected if unable.\n\n#### <a name=\"method-sync-clocks\"></a> .syncClocks()\n\nSend the command to tell the board to start the syncing protocol. Must be connected, streaming and using version +2 firmware.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} resolves if the command was sent to the write queue, rejects if unable.\n\n#### <a name=\"method-sync-clocks-full\"></a> .syncClocksFull()\n\nSend the command to tell the board to start the syncing protocol. Must be connected, streaming and using v2 firmware. Uses the `synced` event to ensure multiple syncs don't overlap.\n\n**Note, this functionality requires OpenBCI Firmware Version 2.0**\n\n**_Returns_** {Promise} resolves if `synced` event is emitted, rejects if not connected or using firmware v2. Resolves with a synced object:\n```js\n{\n    \"boardTime\": 0, // The time contained in the time sync set packet.\n    \"correctedTransmissionTime\": false, // If the confirmation and the set packet arrive in the same serial flush we have big problem! This will be true in this case. See source code for full explanation.\n    \"timeSyncSent\": 0, // The time the `<` was sent to the Dongle.\n    \"timeSyncSentConfirmation\": 0, // The time the `<` was sent to the Board; It's really the time `,` was received from the Dongle.\n    \"timeSyncSetPacket\": 0, // The time the set packet was received from the Board.\n    \"timeRoundTrip\": 0, // Simply timeSyncSetPacket - timeSyncSent.\n    \"timeTransmission\": 0, // Estimated time it took for time sync set packet to be sent from Board to Driver.\n    \"timeOffset\": 0, // The map (or translation) from boardTime to module time.\n    \"timeOffsetMaster\": 0, // The map (or translation) from boardTime to module time averaged over time syncs.\n    \"valid\": false // If there was an error in the process, valid will be false and no time sync was done. It's important to resolve this so we can perform multiple promise syncs as show in the example below.\n}\n```\n\n**Example**\n\nSyncing multiple times to base the offset of the average of the four syncs.\n\n```javascript\nconst Cyton = require('openbci-cyton');\nconst ourBoard = new Cyton({\n  verbose:true\n});\nlet portName = /* INSERT PORT NAME HERE */;\nlet samples = []; // Array to store time synced samples into\nlet timeSyncActivated = false;\n\nourBoard.connect(portName)\n  .then(() => {\n    ourBoard.on('ready',() => {\n      ourBoard.streamStart()\n        .then(() => {\n          /** Could also call `.syncClocksFull()` here */\n        })\n        .catch(err => {\n          console.log(`Error starting stream ${err}`);\n        })\n    });\n    ourBoard.on('sample',sample => {\n      /** If we are not synced, then do that! */\n      if (timeSyncActivated === false) {\n        timeSyncActivated = true;\n        ourBoard.syncClocksFull()\n          .then(syncObj => {\n            if (syncObj.valid) {\n              console.log('1st sync done');\n            }\n            return ourBoard.syncClocksFull();\n          })\n          .then(syncObj => {\n            if (syncObj.valid) {\n              console.log('2nd sync done');\n            }\n            return ourBoard.syncClocksFull();\n          })\n          .then(syncObj => {\n            if (syncObj.valid) {\n              console.log('3rd sync done');\n            }\n            return ourBoard.syncClocksFull();\n          })\n          .then(syncObj => {\n            if (syncObj.valid) {\n              console.log('4th sync done');\n            }\n            /* Do awesome time syncing stuff */\n          })\n          .catch(err => {\n            console.log(`sync err ${err}`);\n          });\n      }\n      if (sample.hasOwnProperty(\"timeStamp\") && sample.hasOwnProperty(\"boardTime\")) {\n        /** If you only want to log samples with time stamps */\n        samples.push(sample);\n      }\n    });\n})\n.catch(err => {\n  console.log(`connect ${err}`);\n});\n\n```\n\n#### <a name=\"method-sync-register-settings\"></a> .syncRegisterSettings()\n\nSyncs the internal channel settings object with a cyton, this will take about over a second because there are delays between the register reads in the firmware.\n\n**_Returns_** a promise, fulfilled with channel settings array, where each element is a standard channel setting object, once the channel settings have been synced and reject on error.\n\n#### <a name=\"method-test-signal\"></a> .testSignal(signal)\n\nApply the internal test signal to all channels.\n\n**_signal_**\n\nA String indicating which test signal to apply\n\n * `dc` - Connect to DC signal\n * `ground` - Connect to internal GND (VDD - VSS)\n * `pulse1xFast` - Connect to test signal 1x Amplitude, fast pulse\n * `pulse1xSlow` - Connect to test signal 1x Amplitude, slow pulse\n * `pulse2xFast` - Connect to test signal 2x Amplitude, fast pulse\n * `pulse2xSlow` - Connect to test signal 2x Amplitude, slow pulse\n * `none` - Reset to default\n\n**_Returns_** a promise, if the commands were sent to write buffer.\n\n#### <a name=\"method-time\"></a> .time()\n\nUses `._sntpNow()` time when sntpTimeSync specified `true` in options, or else Date.now() for time.\n\n**_Returns_** time since UNIX epoch in ms.\n\n#### <a name=\"method-using-version-two-firmware\"></a> .usingVersionTwoFirmware()\n\nConvenience method to determine if you can use firmware v2.x.x capabilities.\n\n**Note, should be called after a [`.softReset()`](#method-soft-reset) because we can parse the output of that to determine if we are using firmware version 2.**\n\n**_Returns_** a boolean, true if using firmware version 2 or greater.\n\n#### <a name=\"method-write\"></a> .write(dataToWrite)\n\nSend commands to the board. Due to the OpenBCI board firmware 1.0, a 10ms spacing **must** be observed between every command sent to the board. This method handles the timing and spacing between characters by adding characters to a global write queue and pulling from it every 10ms. If you are using firmware version +2.0 then you no spacing will be used.\n\n**_dataToWrite_**\n\nEither a single character or an Array of characters\n\n**_Returns_** a promise, fulfilled if the board has been connected and `dataToWrite` has been added to the write queue, rejected if there were any problems.\n\n**Example**\n\nSends a single character command to the board.\n```js\n// ourBoard has fulfilled the promise on .connect() and 'ready' has been observed previously\nourBoard.write('a');\n```\n\nSends an array of bytes\n```js\n// ourBoard has fulfilled the promise on .connect() and 'ready' has been observed previously\nourBoard.write(['x','0','1','0','0','0','0','0','0','X']);\n```\n\nTaking full advantage of the write queue. The following would be sent at t = 0, 10ms, 20ms, 30ms\n```js\nourBoard.write('t');\nourBoard.write('a');\nourBoard.write('c');\nourBoard.write('o');\n```\n\n### <a name=\"event\"></a> Events:\n\n#### <a name=\"event-close\"></a> .on('close', callback)\n\nEmitted when the serial connection to the board is closed.\n\n#### <a name=\"event-dropped-packet\"></a> .on('droppedPacket', callback)\n\nEmitted when a packet (or packets) are dropped. Returns an array.\n\n#### <a name=\"event-eot\"></a> .on('eot', callback)\n\nEmitted when there is an EOT a.k.a. '$$$' with a buffer filled with the data.\n\n#### <a name=\"event-error\"></a> .on('error', callback)\n\nEmitted when there is an on the serial port.\n\n### <a name=\"event-hard-set\"></a> .on('hardSet', callback)\n\nEmitted when the module detects the board is not configured as the options for the module intended and tries to save itself. i.e. when the `daisy` option is `true` and a soft reset message is parsed and the module determines that a daisy was not detected, the module will emit `hardSet` then send an attach daisy command to recover. Either `error` will be emitted if unable to attach or `ready` will be emitted if success.\n\n### <a name=\"event-impedance-array\"></a> .on('impedanceArray', callback)\n\nEmitted when there is a new impedanceArray available. Returns an array.\n\n#### <a name=\"event-query\"></a> .on('query', callback)\n\nEmitted resulting in a call to [`.getChannelSettings()`](#method-get-settings-for-channel) with the channelSettingsObject\n\n#### <a name=\"event-raw-data-packet\"></a> .on('rawDataPacket', callback)\n\nEmitted when there is a new raw data packet available.\n\n#### <a name=\"event-ready\"></a> .on('ready', callback)\n\nEmitted when the board is in a ready to start streaming state.\n\n#### <a name=\"event-sample\"></a> .on('sample', callback)\n\nEmitted when there is a new sample available.\n\n#### <a name=\"event-synced\"></a> .on('synced', callback)\n\nEmitted when there is a new sample available.\n\n### <a name=\"constants\"></a> Constants:\n\nTo use the constants file simply:\n```js\nconst k = require('openbci-utilities').Constants;\n\nconsole.log(k.OBCISimulatorPortName); // prints OpenBCISimulator to the console.\n```\n\n### <a name=\"constants-obcisimulatorportname\"></a> .OBCISimulatorPortName\n\nThe name of the simulator port.\n\n## <a name=\"interfacing-with-other-tools\"></a> Interfacing With Other Tools:\n\n### <a name=\"interfacing-with-other-tools-labstreaminglayer\"></a> LabStreamingLayer\n\n[LabStreamingLayer](https://github.com/sccn/labstreaminglayer) is a tool for streaming or recording time-series data. It can be used to interface with [Matlab](https://github.com/sccn/labstreaminglayer/tree/master/LSL/liblsl-Matlab), [Python](https://github.com/sccn/labstreaminglayer/tree/master/LSL/liblsl-Python), [Unity](https://github.com/xfleckx/LSL4Unity), and many other programs. \n\nTo use LSL with the NodeJS SDK, go to our [labstreaminglayer example](https://github.com/OpenBCI/OpenBCI_NodeJS/tree/master/examples/labstreaminglayer), which contains code that is ready to start an LSL stream of OpenBCI data.\n\nFollow the directions in the [readme](https://github.com/OpenBCI/OpenBCI_NodeJS/blob/master/examples/labstreaminglayer/readme.md) to get started.\n\n\n## <a name=\"developing\"></a> Developing:\n### <a name=\"developing-running\"></a> Running:\n\n```\nnpm install\n```\n\n### <a name=\"developing-testing\"></a> Testing:\n\n```\nnpm test\n```\n\n## <a name=\"contribute\"></a> Contribute:\n\n1. Fork it!\n2. Branch off of `development`: `git checkout development`\n2. Create your feature branch: `git checkout -b my-new-feature`\n3. Make changes\n4. If adding a feature, please add test coverage.\n5. Ensure tests all pass. (`npm test`)\n6. Commit your changes: `git commit -m 'Add some feature'`\n7. Push to the branch: `git push origin my-new-feature`\n8. Submit a pull request. Make sure it is based off of the `development` branch when submitting! :D\n\n## <a name=\"license\"></a> License:\n\nMIT\n\n## <a name=\"roadmap\"></a> Roadmap:\n\n1. Ganglion integration (3.x)\n2. Compatible with node streams (3.x)\n3. Remove factory paradigm from main file (3.x)\n5. ES6/ES7 total adoption (3.x)\n4. Browser support (with browser serialport) (x.x)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/openbci/openbci_nodejs_cyton.git"
  },
  "scripts": {
    "start": "node openBCICyton.js",
    "test": "semistandard | snazzy && mocha test",
    "test-cov": "istanbul cover ./node_modules/mocha/bin/_mocha -- -R spec && codecov",
    "test-lint": "semistandard | snazzy"
  },
  "semistandard": {
    "globals": [
      "after",
      "afterEach",
      "before",
      "beforeEach",
      "context",
      "describe",
      "expect",
      "it",
      "should",
      "xdescribe"
    ]
  },
  "version": "1.1.2"
}
